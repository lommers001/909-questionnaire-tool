(function(factory, root) {
if (typeof define == "function" && define.amd) {define(factory);
} else if (typeof module != "undefined" && typeof exports == "object") {module.exports = factory();
} else {root.rangy = factory();
}
})(function() {var OBJECT = "object", FUNCTION = "function", UNDEFINED = "undefined";var domRangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",
"commonAncestorContainer"];
var domRangeMethods = ["setStart", "setStartBefore", "setStartAfter", "setEnd", "setEndBefore",
"setEndAfter", "collapse", "selectNode", "selectNodeContents", "compareBoundaryPoints", "deleteContents",
"extractContents", "cloneContents", "insertNode", "surroundContents", "cloneRange", "toString", "detach"];var textRangeProperties = ["boundingHeight", "boundingLeft", "boundingTop", "boundingWidth", "htmlText", "text"];
var textRangeMethods = ["collapse", "compareEndPoints", "duplicate", "moveToElementText", "parentElement", "select",
"setEndPoint", "getBoundingClientRect"];/*----------------------------------------------------------------------------------------------------------------*/function isHostMethod(o, p) {
var t = typeof o[p];
return t == FUNCTION || (!!(t == OBJECT && o[p])) || t == "unknown";
}function isHostObject(o, p) {
return !!(typeof o[p] == OBJECT && o[p]);
}function isHostProperty(o, p) {
return typeof o[p] != UNDEFINED;
}
function createMultiplePropertyTest(testFunc) {
return function(o, props) {
var i = props.length;
while (i--) {
if (!testFunc(o, props[i])) {
return false;
}
}
return true;
};
}
var areHostMethods = createMultiplePropertyTest(isHostMethod);
var areHostObjects = createMultiplePropertyTest(isHostObject);
var areHostProperties = createMultiplePropertyTest(isHostProperty);function isTextRange(range) {
return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);
}function getBody(doc) {
return isHostObject(doc, "body") ? doc.body : doc.getElementsByTagName("body")[0];
}var forEach = [].forEach ?
function(arr, func) {
arr.forEach(func);
} :
function(arr, func) {
for (var i = 0, len = arr.length; i < len; ++i) {
func(arr[i], i);
}
};var modules = {};var isBrowser = (typeof window != UNDEFINED && typeof document != UNDEFINED);var util = {
isHostMethod: isHostMethod,
isHostObject: isHostObject,
isHostProperty: isHostProperty,
areHostMethods: areHostMethods,
areHostObjects: areHostObjects,
areHostProperties: areHostProperties,
isTextRange: isTextRange,
getBody: getBody,
forEach: forEach
};var api = {
version: "1.3.0",
initialized: false,
isBrowser: isBrowser,
supported: true,
util: util,
features: {},
modules: modules,
config: {
alertOnFail: false,
alertOnWarn: false,
preferTextRange: false,
autoInitialize: (typeof rangyAutoInitialize == UNDEFINED) ? true : rangyAutoInitialize
}
};function consoleLog(msg) {
if (typeof console != UNDEFINED && isHostMethod(console, "log")) {
console.log(msg);
}
}function alertOrLog(msg, shouldAlert) {
if (isBrowser && shouldAlert) {
alert(msg);
} else{
consoleLog(msg);
}
}function fail(reason) {
api.initialized = true;
api.supported = false;
alertOrLog("Rangy is not supported in this environment. Reason: " + reason, api.config.alertOnFail);
}api.fail = fail;function warn(msg) {
alertOrLog("Rangy warning: " + msg, api.config.alertOnWarn);
}api.warn = warn;
var extend;
if ({}.hasOwnProperty) {
util.extend = extend = function(obj, props, deep) {
var o, p;
for (var i in props) {
if (props.hasOwnProperty(i)) {
o = obj[i];
p = props[i];
if (deep && o !== null && typeof o == "object" && p !== null && typeof p == "object") {
extend(o, p, true);
}
obj[i] = p;
}
}if (props.hasOwnProperty("toString")) {
obj.toString = props.toString;
}
return obj;
};util.createOptions = function(optionsParam, defaults) {
var options = {};
extend(options, defaults);
if (optionsParam) {
extend(options, optionsParam);
}
return options;
};
} else {
fail("hasOwnProperty not supported");
}
if (!isBrowser) {
fail("Rangy can only run in a browser");
}
(function() {
var toArray;if (isBrowser) {
var el = document.createElement("div");
el.appendChild(document.createElement("span"));
var slice = [].slice;
try {
if (slice.call(el.childNodes, 0)[0].nodeType == 1) {
toArray = function(arrayLike) {
return slice.call(arrayLike, 0);
};
}
} catch (e) {}
}if (!toArray) {
toArray = function(arrayLike) {
var arr = [];
for (var i = 0, len = arrayLike.length; i < len; ++i) {
arr[i] = arrayLike[i];
}
return arr;
};
}util.toArray = toArray;
})();var addListener;
if (isBrowser) {
if (isHostMethod(document, "addEventListener")) {
addListener = function(obj, eventType, listener) {
obj.addEventListener(eventType, listener, false);
};
} else if (isHostMethod(document, "attachEvent")) {
addListener = function(obj, eventType, listener) {
obj.attachEvent("on" + eventType, listener);
};
} else {
fail("Document does not have required addEventListener or attachEvent method");
}util.addListener = addListener;
}var initListeners = [];function getErrorDesc(ex) {
return ex.message || ex.description || String(ex);
}
function init() {
if (!isBrowser || api.initialized) {
return;
}
var testRange;
var implementsDomRange = false, implementsTextRange = false;if (isHostMethod(document, "createRange")) {
testRange = document.createRange();
if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {
implementsDomRange = true;
}
}var body = getBody(document);
if (!body || body.nodeName.toLowerCase() != "body") {
fail("No body element found");
return;
}if (body && isHostMethod(body, "createTextRange")) {
testRange = body.createTextRange();
if (isTextRange(testRange)) {
implementsTextRange = true;
}
}if (!implementsDomRange && !implementsTextRange) {
fail("Neither Range nor TextRange are available");
return;
}api.initialized = true;
api.features = {
implementsDomRange: implementsDomRange,
implementsTextRange: implementsTextRange
};
var module, errorMessage;
for (var moduleName in modules) {
if ( (module = modules[moduleName]) instanceof Module ) {
module.init(module, api);
}
}
for (var i = 0, len = initListeners.length; i < len; ++i) {
try {
initListeners[i](api);
} catch (ex) {
errorMessage = "Rangy init listener threw an exception. Continuing. Detail: " + getErrorDesc(ex);
consoleLog(errorMessage);
}
}
}function deprecationNotice(deprecated, replacement, module) {
if (module) {
deprecated += " in module " + module.name;
}
api.warn("DEPRECATED: " + deprecated + " is deprecated. Please use " +
replacement + " instead.");
}function createAliasForDeprecatedMethod(owner, deprecated, replacement, module) {
owner[deprecated] = function() {
deprecationNotice(deprecated, replacement, module);
return owner[replacement].apply(owner, util.toArray(arguments));
};
}util.deprecationNotice = deprecationNotice;
util.createAliasForDeprecatedMethod = createAliasForDeprecatedMethod;
api.init = init;
api.addInitListener = function(listener) {
if (api.initialized) {
listener(api);
} else {
initListeners.push(listener);
}
};var shimListeners = [];api.addShimListener = function(listener) {
shimListeners.push(listener);
};function shim(win) {
win = win || window;
init();
for (var i = 0, len = shimListeners.length; i < len; ++i) {
shimListeners[i](win);
}
}if (isBrowser) {
api.shim = api.createMissingNativeApi = shim;
createAliasForDeprecatedMethod(api, "createMissingNativeApi", "shim");
}function Module(name, dependencies, initializer) {
this.name = name;
this.dependencies = dependencies;
this.initialized = false;
this.supported = false;
this.initializer = initializer;
}Module.prototype = {
init: function() {
var requiredModuleNames = this.dependencies || [];
for (var i = 0, len = requiredModuleNames.length, requiredModule, moduleName; i < len; ++i) {
moduleName = requiredModuleNames[i];requiredModule = modules[moduleName];
if (!requiredModule || !(requiredModule instanceof Module)) {
throw new Error("required module '" + moduleName + "' not found");
}requiredModule.init();if (!requiredModule.supported) {
throw new Error("required module '" + moduleName + "' not supported");
}
}
this.initializer(this);
},fail: function(reason) {
this.initialized = true;
this.supported = false;
throw new Error(reason);
},warn: function(msg) {
api.warn("Module " + this.name + ": " + msg);
},deprecationNotice: function(deprecated, replacement) {
api.warn("DEPRECATED: " + deprecated + " in module " + this.name + " is deprecated. Please use " +
replacement + " instead");
},createError: function(msg) {
return new Error("Error in Rangy " + this.name + " module: " + msg);
}
};function createModule(name, dependencies, initFunc) {
var newModule = new Module(name, dependencies, function(module) {
if (!module.initialized) {
module.initialized = true;
try {
initFunc(api, module);
module.supported = true;
} catch (ex) {
var errorMessage = "Module '" + name + "' failed to load: " + getErrorDesc(ex);
consoleLog(errorMessage);
if (ex.stack) {
consoleLog(ex.stack);
}
}
}
});
modules[name] = newModule;
return newModule;
}api.createModule = function(name) {var initFunc, dependencies;
if (arguments.length == 2) {
initFunc = arguments[1];
dependencies = [];
} else {
initFunc = arguments[2];
dependencies = arguments[1];
}var module = createModule(name, dependencies, initFunc);
if (api.initialized && api.supported) {
module.init();
}
};api.createCoreModule = function(name, dependencies, initFunc) {
createModule(name, dependencies, initFunc);
};/*----------------------------------------------------------------------------------------------------------------*/function RangePrototype() {}
api.RangePrototype = RangePrototype;
api.rangePrototype = new RangePrototype();function SelectionPrototype() {}
api.selectionPrototype = new SelectionPrototype();/*----------------------------------------------------------------------------------------------------------------*/
api.createCoreModule("DomUtil", [], function(api, module) {
var UNDEF = "undefined";
var util = api.util;
var getBody = util.getBody;
if (!util.areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"])) {
module.fail("document missing a Node creation method");
}if (!util.isHostMethod(document, "getElementsByTagName")) {
module.fail("document missing getElementsByTagName method");
}var el = document.createElement("div");
if (!util.areHostMethods(el, ["insertBefore", "appendChild", "cloneNode"] ||
!util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]))) {
module.fail("Incomplete Element implementation");
}
if (!util.isHostProperty(el, "innerHTML")) {
module.fail("Element is missing innerHTML property");
}var textNode = document.createTextNode("test");
if (!util.areHostMethods(textNode, ["splitText", "deleteData", "insertData", "appendData", "cloneNode"] ||
!util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]) ||
!util.areHostProperties(textNode, ["data"]))) {
module.fail("Incomplete Text Node implementation");
}/*----------------------------------------------------------------------------------------------------------------*/
var arrayContains = /*Array.prototype.indexOf ?
function(arr, val) {
return arr.indexOf(val) > -1;
}:*/function(arr, val) {
var i = arr.length;
while (i--) {
if (arr[i] === val) {
return true;
}
}
return false;
};
function isHtmlNamespace(node) {
var ns;
return typeof node.namespaceURI == UNDEF || ((ns = node.namespaceURI) === null || ns == "http://www.w3.org/1999/xhtml");
}function parentElement(node) {
var parent = node.parentNode;
return (parent.nodeType == 1) ? parent : null;
}function getNodeIndex(node) {
var i = 0;
while( (node = node.previousSibling) ) {
++i;
}
return i;
}function getNodeLength(node) {
switch (node.nodeType) {
case 7:
case 10:
return 0;
case 3:
case 8:
return node.length;
default:
return node.childNodes.length;
}
}function getCommonAncestor(node1, node2) {
var ancestors = [], n;
for (n = node1; n; n = n.parentNode) {
ancestors.push(n);
}for (n = node2; n; n = n.parentNode) {
if (arrayContains(ancestors, n)) {
return n;
}
}return null;
}function isAncestorOf(ancestor, descendant, selfIsAncestor) {
var n = selfIsAncestor ? descendant : descendant.parentNode;
while (n) {
if (n === ancestor) {
return true;
} else {
n = n.parentNode;
}
}
return false;
}function isOrIsAncestorOf(ancestor, descendant) {
return isAncestorOf(ancestor, descendant, true);
}function getClosestAncestorIn(node, ancestor, selfIsAncestor) {
var p, n = selfIsAncestor ? node : node.parentNode;
while (n) {
p = n.parentNode;
if (p === ancestor) {
return n;
}
n = p;
}
return null;
}function isCharacterDataNode(node) {
var t = node.nodeType;
return t == 3 || t == 4 || t == 8 ; 
}function isTextOrCommentNode(node) {
if (!node) {
return false;
}
var t = node.nodeType;
return t == 3 || t == 8 ; 
}function insertAfter(node, precedingNode) {
var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;
if (nextNode) {
parent.insertBefore(node, nextNode);
} else {
parent.appendChild(node);
}
return node;
}
function splitDataNode(node, index, positionsToPreserve) {
var newNode = node.cloneNode(false);
newNode.deleteData(0, index);
node.deleteData(index, node.length - index);
insertAfter(newNode, node);
if (positionsToPreserve) {
for (var i = 0, position; position = positionsToPreserve[i++]; ) {if (position.node == node && position.offset > index) {
position.node = newNode;
position.offset -= index;
}else if (position.node == node.parentNode && position.offset > getNodeIndex(node)) {
++position.offset;
}
}
}
return newNode;
}function getDocument(node) {
if (node.nodeType == 9) {
return node;
} else if (typeof node.ownerDocument != UNDEF) {
return node.ownerDocument;
} else if (typeof node.document != UNDEF) {
return node.document;
} else if (node.parentNode) {
return getDocument(node.parentNode);
} else {
throw module.createError("getDocument: no document found for node");
}
}function getWindow(node) {
var doc = getDocument(node);
if (typeof doc.defaultView != UNDEF) {
return doc.defaultView;
} else if (typeof doc.parentWindow != UNDEF) {
return doc.parentWindow;
} else {
throw module.createError("Cannot get a window object for node");
}
}function getIframeDocument(iframeEl) {
if (typeof iframeEl.contentDocument != UNDEF) {
return iframeEl.contentDocument;
} else if (typeof iframeEl.contentWindow != UNDEF) {
return iframeEl.contentWindow.document;
} else {
throw module.createError("getIframeDocument: No Document object found for iframe element");
}
}function getIframeWindow(iframeEl) {
if (typeof iframeEl.contentWindow != UNDEF) {
return iframeEl.contentWindow;
} else if (typeof iframeEl.contentDocument != UNDEF) {
return iframeEl.contentDocument.defaultView;
} else {
throw module.createError("getIframeWindow: No Window object found for iframe element");
}
}
function isWindow(obj) {
return obj && util.isHostMethod(obj, "setTimeout") && util.isHostObject(obj, "document");
}function getContentDocument(obj, module, methodName) {
var doc;if (!obj) {
doc = document;
}
else if (util.isHostProperty(obj, "nodeType")) {
doc = (obj.nodeType == 1 && obj.tagName.toLowerCase() == "iframe") ?
getIframeDocument(obj) : getDocument(obj);
}
else if (isWindow(obj)) {
doc = obj.document;
}if (!doc) {
throw module.createError(methodName + "(): Parameter must be a Window object or DOM node");
}return doc;
}function getRootContainer(node) {
var parent;
while ( (parent = node.parentNode) ) {
node = parent;
}
return node;
}function comparePoints(nodeA, offsetA, nodeB, offsetB) {var nodeC, root, childA, childB, n;
if (nodeA == nodeB) {return offsetA === offsetB ? 0 : (offsetA < offsetB) ? -1 : 1;
} else if ( (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) ) {return offsetA <= getNodeIndex(nodeC) ? -1 : 1;
} else if ( (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) ) {return getNodeIndex(nodeC) < offsetB? -1 : 1;
} else {
root = getCommonAncestor(nodeA, nodeB);
if (!root) {
throw new Error("comparePoints error: nodes have no common ancestor");
}
childA = (nodeA === root) ? root : getClosestAncestorIn(nodeA, root, true);
childB = (nodeB === root) ? root : getClosestAncestorIn(nodeB, root, true);if (childA === childB) {throw module.createError("comparePoints got to case 4 and childA and childB are the same!");
} else {
n = root.firstChild;
while (n) {
if (n === childA) {
return -1;
} else if (n === childB) {
return 1;
}
n = n.nextSibling;
}
}
}
}/*----------------------------------------------------------------------------------------------------------------*/
var crashyTextNodes = false;function isBrokenNode(node) {
var n;
try {
n = node.parentNode;
return false;
} catch (e) {
return true;
}
}(function() {
var el = document.createElement("b");
el.innerHTML = "1";
var textNode = el.firstChild;
el.innerHTML = "<br />";
crashyTextNodes = isBrokenNode(textNode);api.features.crashyTextNodes = crashyTextNodes;
})();/*----------------------------------------------------------------------------------------------------------------*/function inspectNode(node) {
if (!node) {
return "[No node]";
}
if (crashyTextNodes && isBrokenNode(node)) {
return "[Broken node]";
}
if (isCharacterDataNode(node)) {
return '"' + node.data + '"';
}
if (node.nodeType == 1) {
var idAttr = node.id ? ' id="' + node.id + '"' : "";
return "<" + node.nodeName + idAttr + ">[index:" + getNodeIndex(node) + ",length:" + node.childNodes.length + "][" + (node.innerHTML || "[innerHTML not supported]").slice(0, 25) + "]";
}
return node.nodeName;
}function fragmentFromNodeChildren(node) {
var fragment = getDocument(node).createDocumentFragment(), child;
while ( (child = node.firstChild) ) {
fragment.appendChild(child);
}
return fragment;
}var getComputedStyleProperty;
if (typeof window.getComputedStyle != UNDEF) {
getComputedStyleProperty = function(el, propName) {
return getWindow(el).getComputedStyle(el, null)[propName];
};
} else if (typeof document.documentElement.currentStyle != UNDEF) {
getComputedStyleProperty = function(el, propName) {
return el.currentStyle ? el.currentStyle[propName] : "";
};
} else {
module.fail("No means of obtaining computed style properties found");
}function createTestElement(doc, html, contentEditable) {
var body = getBody(doc);
var el = doc.createElement("div");
el.contentEditable = "" + !!contentEditable;
if (html) {
el.innerHTML = html;
}
var bodyFirstChild = body.firstChild;
if (bodyFirstChild) {
body.insertBefore(el, bodyFirstChild);
} else {
body.appendChild(el);
}return el;
}function removeNode(node) {
return node.parentNode.removeChild(node);
}function NodeIterator(root) {
this.root = root;
this._next = root;
}NodeIterator.prototype = {
_current: null,hasNext: function() {
return !!this._next;
},next: function() {
var n = this._current = this._next;
var child, next;
if (this._current) {
child = n.firstChild;
if (child) {
this._next = child;
} else {
next = null;
while ((n !== this.root) && !(next = n.nextSibling)) {
n = n.parentNode;
}
this._next = next;
}
}
return this._current;
},detach: function() {
this._current = this._next = this.root = null;
}
};function createIterator(root) {
return new NodeIterator(root);
}function DomPosition(node, offset) {
this.node = node;
this.offset = offset;
}DomPosition.prototype = {
equals: function(pos) {
return !!pos && this.node === pos.node && this.offset == pos.offset;
},inspect: function() {
return "[DomPosition(" + inspectNode(this.node) + ":" + this.offset + ")]";
},toString: function() {
return this.inspect();
}
};function DOMException(codeName) {
this.code = this[codeName];
this.codeName = codeName;
this.message = "DOMException: " + this.codeName;
}DOMException.prototype = {
INDEX_SIZE_ERR: 1,
HIERARCHY_REQUEST_ERR: 3,
WRONG_DOCUMENT_ERR: 4,
NO_MODIFICATION_ALLOWED_ERR: 7,
NOT_FOUND_ERR: 8,
NOT_SUPPORTED_ERR: 9,
INVALID_STATE_ERR: 11,
INVALID_NODE_TYPE_ERR: 24
};DOMException.prototype.toString = function() {
return this.message;
};api.dom = {
arrayContains: arrayContains,
isHtmlNamespace: isHtmlNamespace,
parentElement: parentElement,
getNodeIndex: getNodeIndex,
getNodeLength: getNodeLength,
getCommonAncestor: getCommonAncestor,
isAncestorOf: isAncestorOf,
isOrIsAncestorOf: isOrIsAncestorOf,
getClosestAncestorIn: getClosestAncestorIn,
isCharacterDataNode: isCharacterDataNode,
isTextOrCommentNode: isTextOrCommentNode,
insertAfter: insertAfter,
splitDataNode: splitDataNode,
getDocument: getDocument,
getWindow: getWindow,
getIframeWindow: getIframeWindow,
getIframeDocument: getIframeDocument,
getBody: getBody,
isWindow: isWindow,
getContentDocument: getContentDocument,
getRootContainer: getRootContainer,
comparePoints: comparePoints,
isBrokenNode: isBrokenNode,
inspectNode: inspectNode,
getComputedStyleProperty: getComputedStyleProperty,
createTestElement: createTestElement,
removeNode: removeNode,
fragmentFromNodeChildren: fragmentFromNodeChildren,
createIterator: createIterator,
DomPosition: DomPosition
};api.DOMException = DOMException;
});/*----------------------------------------------------------------------------------------------------------------*/
api.createCoreModule("DomRange", ["DomUtil"], function(api, module) {
var dom = api.dom;
var util = api.util;
var DomPosition = dom.DomPosition;
var DOMException = api.DOMException;var isCharacterDataNode = dom.isCharacterDataNode;
var getNodeIndex = dom.getNodeIndex;
var isOrIsAncestorOf = dom.isOrIsAncestorOf;
var getDocument = dom.getDocument;
var comparePoints = dom.comparePoints;
var splitDataNode = dom.splitDataNode;
var getClosestAncestorIn = dom.getClosestAncestorIn;
var getNodeLength = dom.getNodeLength;
var arrayContains = dom.arrayContains;
var getRootContainer = dom.getRootContainer;
var crashyTextNodes = api.features.crashyTextNodes;var removeNode = dom.removeNode;/*----------------------------------------------------------------------------------------------------------------*/function isNonTextPartiallySelected(node, range) {
return (node.nodeType != 3) &&
 (isOrIsAncestorOf(node, range.startContainer) || isOrIsAncestorOf(node, range.endContainer));
}function getRangeDocument(range) {
return range.document || getDocument(range.startContainer);
}function getRangeRoot(range) {
return getRootContainer(range.startContainer);
}function getBoundaryBeforeNode(node) {
return new DomPosition(node.parentNode, getNodeIndex(node));
}function getBoundaryAfterNode(node) {
return new DomPosition(node.parentNode, getNodeIndex(node) + 1);
}function insertNodeAtPosition(node, n, o) {
var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;
if (isCharacterDataNode(n)) {
if (o == n.length) {
dom.insertAfter(node, n);
} else {
n.parentNode.insertBefore(node, o == 0 ? n : splitDataNode(n, o));
}
} else if (o >= n.childNodes.length) {
n.appendChild(node);
} else {
n.insertBefore(node, n.childNodes[o]);
}
return firstNodeInserted;
}function rangesIntersect(rangeA, rangeB, touchingIsIntersecting) {
assertRangeValid(rangeA);
assertRangeValid(rangeB);if (getRangeDocument(rangeB) != getRangeDocument(rangeA)) {
throw new DOMException("WRONG_DOCUMENT_ERR");
}var startComparison = comparePoints(rangeA.startContainer, rangeA.startOffset, rangeB.endContainer, rangeB.endOffset),
endComparison = comparePoints(rangeA.endContainer, rangeA.endOffset, rangeB.startContainer, rangeB.startOffset);return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
}function cloneSubtree(iterator) {
var partiallySelected;
for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {
partiallySelected = iterator.isPartiallySelectedSubtree();
node = node.cloneNode(!partiallySelected);
if (partiallySelected) {
subIterator = iterator.getSubtreeIterator();
node.appendChild(cloneSubtree(subIterator));
subIterator.detach();
}if (node.nodeType == 10) { 
throw new DOMException("HIERARCHY_REQUEST_ERR");
}
frag.appendChild(node);
}
return frag;
}function iterateSubtree(rangeIterator, func, iteratorState) {
var it, n;
iteratorState = iteratorState || { stop: false };
for (var node, subRangeIterator; node = rangeIterator.next(); ) {
if (rangeIterator.isPartiallySelectedSubtree()) {
if (func(node) === false) {
iteratorState.stop = true;
return;
} else {
subRangeIterator = rangeIterator.getSubtreeIterator();
iterateSubtree(subRangeIterator, func, iteratorState);
subRangeIterator.detach();
if (iteratorState.stop) {
return;
}
}
} else {
it = dom.createIterator(node);
while ( (n = it.next()) ) {
if (func(n) === false) {
iteratorState.stop = true;
return;
}
}
}
}
}function deleteSubtree(iterator) {
var subIterator;
while (iterator.next()) {
if (iterator.isPartiallySelectedSubtree()) {
subIterator = iterator.getSubtreeIterator();
deleteSubtree(subIterator);
subIterator.detach();
} else {
iterator.remove();
}
}
}function extractSubtree(iterator) {
for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {if (iterator.isPartiallySelectedSubtree()) {
node = node.cloneNode(false);
subIterator = iterator.getSubtreeIterator();
node.appendChild(extractSubtree(subIterator));
subIterator.detach();
} else {
iterator.remove();
}
if (node.nodeType == 10) { 
throw new DOMException("HIERARCHY_REQUEST_ERR");
}
frag.appendChild(node);
}
return frag;
}function getNodesInRange(range, nodeTypes, filter) {
var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;
var filterExists = !!filter;
if (filterNodeTypes) {
regex = new RegExp("^(" + nodeTypes.join("|") + ")$");
}var nodes = [];
iterateSubtree(new RangeIterator(range, false), function(node) {
if (filterNodeTypes && !regex.test(node.nodeType)) {
return;
}
if (filterExists && !filter(node)) {
return;
}
var sc = range.startContainer;
if (node == sc && isCharacterDataNode(sc) && range.startOffset == sc.length) {
return;
}var ec = range.endContainer;
if (node == ec && isCharacterDataNode(ec) && range.endOffset == 0) {
return;
}nodes.push(node);
});
return nodes;
}function inspect(range) {
var name = (typeof range.getName == "undefined") ? "Range" : range.getName();
return "[" + name + "(" + dom.inspectNode(range.startContainer) + ":" + range.startOffset + ", " +
dom.inspectNode(range.endContainer) + ":" + range.endOffset + ")]";
}/*----------------------------------------------------------------------------------------------------------------*/function RangeIterator(range, clonePartiallySelectedTextNodes) {
this.range = range;
this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;
if (!range.collapsed) {
this.sc = range.startContainer;
this.so = range.startOffset;
this.ec = range.endContainer;
this.eo = range.endOffset;
var root = range.commonAncestorContainer;if (this.sc === this.ec && isCharacterDataNode(this.sc)) {
this.isSingleCharacterDataNode = true;
this._first = this._last = this._next = this.sc;
} else {
this._first = this._next = (this.sc === root && !isCharacterDataNode(this.sc)) ?
this.sc.childNodes[this.so] : getClosestAncestorIn(this.sc, root, true);
this._last = (this.ec === root && !isCharacterDataNode(this.ec)) ?
this.ec.childNodes[this.eo - 1] : getClosestAncestorIn(this.ec, root, true);
}
}
}RangeIterator.prototype = {
_current: null,
_next: null,
_first: null,
_last: null,
isSingleCharacterDataNode: false,reset: function() {
this._current = null;
this._next = this._first;
},hasNext: function() {
return !!this._next;
},next: function() {var current = this._current = this._next;
if (current) {
this._next = (current !== this._last) ? current.nextSibling : null;
if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {
if (current === this.ec) {
(current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);
}
if (this._current === this.sc) {
(current = current.cloneNode(true)).deleteData(0, this.so);
}
}
}return current;
},remove: function() {
var current = this._current, start, end;if (isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {
start = (current === this.sc) ? this.so : 0;
end = (current === this.ec) ? this.eo : current.length;
if (start != end) {
current.deleteData(start, end - start);
}
} else {
if (current.parentNode) {
removeNode(current);
} else {
}
}
},
isPartiallySelectedSubtree: function() {
var current = this._current;
return isNonTextPartiallySelected(current, this.range);
},getSubtreeIterator: function() {
var subRange;
if (this.isSingleCharacterDataNode) {
subRange = this.range.cloneRange();
subRange.collapse(false);
} else {
subRange = new Range(getRangeDocument(this.range));
var current = this._current;
var startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);if (isOrIsAncestorOf(current, this.sc)) {
startContainer = this.sc;
startOffset = this.so;
}
if (isOrIsAncestorOf(current, this.ec)) {
endContainer = this.ec;
endOffset = this.eo;
}updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);
}
return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);
},detach: function() {
this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;
}
};/*----------------------------------------------------------------------------------------------------------------*/var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];
var rootContainerNodeTypes = [2, 9, 11];
var readonlyNodeTypes = [5, 6, 10, 12];
var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];
var surroundNodeTypes = [1, 3, 4, 5, 7, 8];function createAncestorFinder(nodeTypes) {
return function(node, selfIsAncestor) {
var t, n = selfIsAncestor ? node : node.parentNode;
while (n) {
t = n.nodeType;
if (arrayContains(nodeTypes, t)) {
return n;
}
n = n.parentNode;
}
return null;
};
}var getDocumentOrFragmentContainer = createAncestorFinder( [9, 11] );
var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);
var getDocTypeNotationEntityAncestor = createAncestorFinder( [6, 10, 12] );function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {
if (getDocTypeNotationEntityAncestor(node, allowSelf)) {
throw new DOMException("INVALID_NODE_TYPE_ERR");
}
}function assertValidNodeType(node, invalidTypes) {
if (!arrayContains(invalidTypes, node.nodeType)) {
throw new DOMException("INVALID_NODE_TYPE_ERR");
}
}function assertValidOffset(node, offset) {
if (offset < 0 || offset > (isCharacterDataNode(node) ? node.length : node.childNodes.length)) {
throw new DOMException("INDEX_SIZE_ERR");
}
}function assertSameDocumentOrFragment(node1, node2) {
if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {
throw new DOMException("WRONG_DOCUMENT_ERR");
}
}function assertNodeNotReadOnly(node) {
if (getReadonlyAncestor(node, true)) {
throw new DOMException("NO_MODIFICATION_ALLOWED_ERR");
}
}function assertNode(node, codeName) {
if (!node) {
throw new DOMException(codeName);
}
}function isValidOffset(node, offset) {
return offset <= (isCharacterDataNode(node) ? node.length : node.childNodes.length);
}function isRangeValid(range) {
return (!!range.startContainer && !!range.endContainer &&
!(crashyTextNodes && (dom.isBrokenNode(range.startContainer) || dom.isBrokenNode(range.endContainer))) &&
getRootContainer(range.startContainer) == getRootContainer(range.endContainer) &&
isValidOffset(range.startContainer, range.startOffset) &&
isValidOffset(range.endContainer, range.endOffset));
}function assertRangeValid(range) {
if (!isRangeValid(range)) {
throw new Error("Range error: Range is not valid. This usually happens after DOM mutation. Range: (" + range.inspect() + ")");
}
}/*----------------------------------------------------------------------------------------------------------------*/
var styleEl = document.createElement("style");
var htmlParsingConforms = false;
try {
styleEl.innerHTML = "<b>x</b>";
htmlParsingConforms = (styleEl.firstChild.nodeType == 3); 
} catch (e) {}api.features.htmlParsingConforms = htmlParsingConforms;var createContextualFragment = htmlParsingConforms ?function(fragmentStr) {var node = this.startContainer;
var doc = getDocument(node);if (!node) {
throw new DOMException("INVALID_STATE_ERR");
}var el = null;
if (node.nodeType == 1) {
el = node;
} else if (isCharacterDataNode(node)) {
el = dom.parentElement(node);
}
if (el === null || (
el.nodeName == "HTML" &&
dom.isHtmlNamespace(getDocument(el).documentElement) &&
dom.isHtmlNamespace(el)
)) {el = doc.createElement("body");
} else {
el = el.cloneNode(false);
}el.innerHTML = fragmentStr;return dom.fragmentFromNodeChildren(el);
} :function(fragmentStr) {
var doc = getRangeDocument(this);
var el = doc.createElement("body");
el.innerHTML = fragmentStr;return dom.fragmentFromNodeChildren(el);
};function splitRangeBoundaries(range, positionsToPreserve) {
assertRangeValid(range);var sc = range.startContainer, so = range.startOffset, ec = range.endContainer, eo = range.endOffset;
var startEndSame = (sc === ec);if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {
splitDataNode(ec, eo, positionsToPreserve);
}if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {
sc = splitDataNode(sc, so, positionsToPreserve);
if (startEndSame) {
eo -= so;
ec = sc;
} else if (ec == sc.parentNode && eo >= getNodeIndex(sc)) {
eo++;
}
so = 0;
}
range.setStartAndEnd(sc, so, ec, eo);
}function rangeToHtml(range) {
assertRangeValid(range);
var container = range.commonAncestorContainer.parentNode.cloneNode(false);
container.appendChild( range.cloneContents() );
return container.innerHTML;
}/*----------------------------------------------------------------------------------------------------------------*/var rangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",
"commonAncestorContainer"];var s2s = 0, s2e = 1, e2e = 2, e2s = 3;
var n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;util.extend(api.rangePrototype, {
compareBoundaryPoints: function(how, range) {
assertRangeValid(this);
assertSameDocumentOrFragment(this.startContainer, range.startContainer);var nodeA, offsetA, nodeB, offsetB;
var prefixA = (how == e2s || how == s2s) ? "start" : "end";
var prefixB = (how == s2e || how == s2s) ? "start" : "end";
nodeA = this[prefixA + "Container"];
offsetA = this[prefixA + "Offset"];
nodeB = range[prefixB + "Container"];
offsetB = range[prefixB + "Offset"];
return comparePoints(nodeA, offsetA, nodeB, offsetB);
},insertNode: function(node) {
assertRangeValid(this);
assertValidNodeType(node, insertableNodeTypes);
assertNodeNotReadOnly(this.startContainer);if (isOrIsAncestorOf(node, this.startContainer)) {
throw new DOMException("HIERARCHY_REQUEST_ERR");
}var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);
this.setStartBefore(firstNodeInserted);
},cloneContents: function() {
assertRangeValid(this);var clone, frag;
if (this.collapsed) {
return getRangeDocument(this).createDocumentFragment();
} else {
if (this.startContainer === this.endContainer && isCharacterDataNode(this.startContainer)) {
clone = this.startContainer.cloneNode(true);
clone.data = clone.data.slice(this.startOffset, this.endOffset);
frag = getRangeDocument(this).createDocumentFragment();
frag.appendChild(clone);
return frag;
} else {
var iterator = new RangeIterator(this, true);
clone = cloneSubtree(iterator);
iterator.detach();
}
return clone;
}
},canSurroundContents: function() {
assertRangeValid(this);
assertNodeNotReadOnly(this.startContainer);
assertNodeNotReadOnly(this.endContainer);var iterator = new RangeIterator(this, true);
var boundariesInvalid = (iterator._first && (isNonTextPartiallySelected(iterator._first, this)) ||
(iterator._last && isNonTextPartiallySelected(iterator._last, this)));
iterator.detach();
return !boundariesInvalid;
},surroundContents: function(node) {
assertValidNodeType(node, surroundNodeTypes);if (!this.canSurroundContents()) {
throw new DOMException("INVALID_STATE_ERR");
}
var content = this.extractContents();
if (node.hasChildNodes()) {
while (node.lastChild) {
node.removeChild(node.lastChild);
}
}
insertNodeAtPosition(node, this.startContainer, this.startOffset);
node.appendChild(content);this.selectNode(node);
},cloneRange: function() {
assertRangeValid(this);
var range = new Range(getRangeDocument(this));
var i = rangeProperties.length, prop;
while (i--) {
prop = rangeProperties[i];
range[prop] = this[prop];
}
return range;
},toString: function() {
assertRangeValid(this);
var sc = this.startContainer;
if (sc === this.endContainer && isCharacterDataNode(sc)) {
return (sc.nodeType == 3 || sc.nodeType == 4) ? sc.data.slice(this.startOffset, this.endOffset) : "";
} else {
var textParts = [], iterator = new RangeIterator(this, true);
iterateSubtree(iterator, function(node) {if (node.nodeType == 3 || node.nodeType == 4) {
textParts.push(node.data);
}
});
iterator.detach();
return textParts.join("");
}
},
compareNode: function(node) {
assertRangeValid(this);var parent = node.parentNode;
var nodeIndex = getNodeIndex(node);if (!parent) {
throw new DOMException("NOT_FOUND_ERR");
}var startComparison = this.comparePoint(parent, nodeIndex),
endComparison = this.comparePoint(parent, nodeIndex + 1);if (startComparison < 0) { 
return (endComparison > 0) ? n_b_a : n_b;
} else {
return (endComparison > 0) ? n_a : n_i;
}
},comparePoint: function(node, offset) {
assertRangeValid(this);
assertNode(node, "HIERARCHY_REQUEST_ERR");
assertSameDocumentOrFragment(node, this.startContainer);if (comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {
return -1;
} else if (comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {
return 1;
}
return 0;
},createContextualFragment: createContextualFragment,toHtml: function() {
return rangeToHtml(this);
},intersectsNode: function(node, touchingIsIntersecting) {
assertRangeValid(this);
if (getRootContainer(node) != getRangeRoot(this)) {
return false;
}var parent = node.parentNode, offset = getNodeIndex(node);
if (!parent) {
return true;
}var startComparison = comparePoints(parent, offset, this.endContainer, this.endOffset),
endComparison = comparePoints(parent, offset + 1, this.startContainer, this.startOffset);return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
},isPointInRange: function(node, offset) {
assertRangeValid(this);
assertNode(node, "HIERARCHY_REQUEST_ERR");
assertSameDocumentOrFragment(node, this.startContainer);return (comparePoints(node, offset, this.startContainer, this.startOffset) >= 0) &&
 (comparePoints(node, offset, this.endContainer, this.endOffset) <= 0);
},
intersectsRange: function(range) {
return rangesIntersect(this, range, false);
},
intersectsOrTouchesRange: function(range) {
return rangesIntersect(this, range, true);
},intersection: function(range) {
if (this.intersectsRange(range)) {
var startComparison = comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset),
endComparison = comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);var intersectionRange = this.cloneRange();
if (startComparison == -1) {
intersectionRange.setStart(range.startContainer, range.startOffset);
}
if (endComparison == 1) {
intersectionRange.setEnd(range.endContainer, range.endOffset);
}
return intersectionRange;
}
return null;
},union: function(range) {
if (this.intersectsOrTouchesRange(range)) {
var unionRange = this.cloneRange();
if (comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {
unionRange.setStart(range.startContainer, range.startOffset);
}
if (comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {
unionRange.setEnd(range.endContainer, range.endOffset);
}
return unionRange;
} else {
throw new DOMException("Ranges do not intersect");
}
},containsNode: function(node, allowPartial) {
if (allowPartial) {
return this.intersectsNode(node, false);
} else {
return this.compareNode(node) == n_i;
}
},containsNodeContents: function(node) {
return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, getNodeLength(node)) <= 0;
},containsRange: function(range) {
var intersection = this.intersection(range);
return intersection !== null && range.equals(intersection);
},containsNodeText: function(node) {
var nodeRange = this.cloneRange();
nodeRange.selectNode(node);
var textNodes = nodeRange.getNodes([3]);
if (textNodes.length > 0) {
nodeRange.setStart(textNodes[0], 0);
var lastTextNode = textNodes.pop();
nodeRange.setEnd(lastTextNode, lastTextNode.length);
return this.containsRange(nodeRange);
} else {
return this.containsNodeContents(node);
}
},getNodes: function(nodeTypes, filter) {
assertRangeValid(this);
return getNodesInRange(this, nodeTypes, filter);
},getDocument: function() {
return getRangeDocument(this);
},collapseBefore: function(node) {
this.setEndBefore(node);
this.collapse(false);
},collapseAfter: function(node) {
this.setStartAfter(node);
this.collapse(true);
},getBookmark: function(containerNode) {
var doc = getRangeDocument(this);
var preSelectionRange = api.createRange(doc);
containerNode = containerNode || dom.getBody(doc);
preSelectionRange.selectNodeContents(containerNode);
var range = this.intersection(preSelectionRange);
var start = 0, end = 0;
if (range) {
preSelectionRange.setEnd(range.startContainer, range.startOffset);
start = preSelectionRange.toString().length;
end = start + range.toString().length;
}return {
start: start,
end: end,
containerNode: containerNode
};
},moveToBookmark: function(bookmark) {
var containerNode = bookmark.containerNode;
var charIndex = 0;
this.setStart(containerNode, 0);
this.collapse(true);
var nodeStack = [containerNode], node, foundStart = false, stop = false;
var nextCharIndex, i, childNodes;while (!stop && (node = nodeStack.pop())) {
if (node.nodeType == 3) {
nextCharIndex = charIndex + node.length;
if (!foundStart && bookmark.start >= charIndex && bookmark.start <= nextCharIndex) {
this.setStart(node, bookmark.start - charIndex);
foundStart = true;
}
if (foundStart && bookmark.end >= charIndex && bookmark.end <= nextCharIndex) {
this.setEnd(node, bookmark.end - charIndex);
stop = true;
}
charIndex = nextCharIndex;
} else {
childNodes = node.childNodes;
i = childNodes.length;
while (i--) {
nodeStack.push(childNodes[i]);
}
}
}
},getName: function() {
return "DomRange";
},equals: function(range) {
return Range.rangesEqual(this, range);
},isValid: function() {
return isRangeValid(this);
},inspect: function() {
return inspect(this);
},detach: function() {}
});function copyComparisonConstantsToObject(obj) {
obj.START_TO_START = s2s;
obj.START_TO_END = s2e;
obj.END_TO_END = e2e;
obj.END_TO_START = e2s;obj.NODE_BEFORE = n_b;
obj.NODE_AFTER = n_a;
obj.NODE_BEFORE_AND_AFTER = n_b_a;
obj.NODE_INSIDE = n_i;
}function copyComparisonConstants(constructor) {
copyComparisonConstantsToObject(constructor);
copyComparisonConstantsToObject(constructor.prototype);
}function createRangeContentRemover(remover, boundaryUpdater) {
return function() {
assertRangeValid(this);var sc = this.startContainer, so = this.startOffset, root = this.commonAncestorContainer;var iterator = new RangeIterator(this, true);
var node, boundary;
if (sc !== root) {
node = getClosestAncestorIn(sc, root, true);
boundary = getBoundaryAfterNode(node);
sc = boundary.node;
so = boundary.offset;
}
iterateSubtree(iterator, assertNodeNotReadOnly);iterator.reset();
var returnValue = remover(iterator);
iterator.detach();
boundaryUpdater(this, sc, so, sc, so);return returnValue;
};
}function createPrototypeRange(constructor, boundaryUpdater) {
function createBeforeAfterNodeSetter(isBefore, isStart) {
return function(node) {
assertValidNodeType(node, beforeAfterNodeTypes);
assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);
(isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);
};
}function setRangeStart(range, node, offset) {
var ec = range.endContainer, eo = range.endOffset;
if (node !== range.startContainer || offset !== range.startOffset) {
if (getRootContainer(node) != getRootContainer(ec) || comparePoints(node, offset, ec, eo) == 1) {
ec = node;
eo = offset;
}
boundaryUpdater(range, node, offset, ec, eo);
}
}function setRangeEnd(range, node, offset) {
var sc = range.startContainer, so = range.startOffset;
if (node !== range.endContainer || offset !== range.endOffset) {
if (getRootContainer(node) != getRootContainer(sc) || comparePoints(node, offset, sc, so) == -1) {
sc = node;
so = offset;
}
boundaryUpdater(range, sc, so, node, offset);
}
}
var F = function() {};
F.prototype = api.rangePrototype;
constructor.prototype = new F();util.extend(constructor.prototype, {
setStart: function(node, offset) {
assertNoDocTypeNotationEntityAncestor(node, true);
assertValidOffset(node, offset);setRangeStart(this, node, offset);
},setEnd: function(node, offset) {
assertNoDocTypeNotationEntityAncestor(node, true);
assertValidOffset(node, offset);setRangeEnd(this, node, offset);
},/**
 * Convenience method to set a range's start and end boundaries. Overloaded as follows:
 * - Two parameters (node, offset) creates a collapsed range at that position
 * - Three parameters (node, startOffset, endOffset) creates a range contained with node starting at
 * startOffset and ending at endOffset
 * - Four parameters (startNode, startOffset, endNode, endOffset) creates a range starting at startOffset in
 * startNode and ending at endOffset in endNode
 */
setStartAndEnd: function() {
var args = arguments;
var sc = args[0], so = args[1], ec = sc, eo = so;switch (args.length) {
case 3:
eo = args[2];
break;
case 4:
ec = args[2];
eo = args[3];
break;
}boundaryUpdater(this, sc, so, ec, eo);
},setBoundary: function(node, offset, isStart) {
this["set" + (isStart ? "Start" : "End")](node, offset);
},setStartBefore: createBeforeAfterNodeSetter(true, true),
setStartAfter: createBeforeAfterNodeSetter(false, true),
setEndBefore: createBeforeAfterNodeSetter(true, false),
setEndAfter: createBeforeAfterNodeSetter(false, false),collapse: function(isStart) {
assertRangeValid(this);
if (isStart) {
boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);
} else {
boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);
}
},selectNodeContents: function(node) {
assertNoDocTypeNotationEntityAncestor(node, true);boundaryUpdater(this, node, 0, node, getNodeLength(node));
},selectNode: function(node) {
assertNoDocTypeNotationEntityAncestor(node, false);
assertValidNodeType(node, beforeAfterNodeTypes);var start = getBoundaryBeforeNode(node), end = getBoundaryAfterNode(node);
boundaryUpdater(this, start.node, start.offset, end.node, end.offset);
},extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),canSurroundContents: function() {
assertRangeValid(this);
assertNodeNotReadOnly(this.startContainer);
assertNodeNotReadOnly(this.endContainer);var iterator = new RangeIterator(this, true);
var boundariesInvalid = (iterator._first && isNonTextPartiallySelected(iterator._first, this) ||
(iterator._last && isNonTextPartiallySelected(iterator._last, this)));
iterator.detach();
return !boundariesInvalid;
},splitBoundaries: function() {
splitRangeBoundaries(this);
},splitBoundariesPreservingPositions: function(positionsToPreserve) {
splitRangeBoundaries(this, positionsToPreserve);
},normalizeBoundaries: function() {
assertRangeValid(this);var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;var mergeForward = function(node) {
var sibling = node.nextSibling;
if (sibling && sibling.nodeType == node.nodeType) {
ec = node;
eo = node.length;
node.appendData(sibling.data);
removeNode(sibling);
}
};var mergeBackward = function(node) {
var sibling = node.previousSibling;
if (sibling && sibling.nodeType == node.nodeType) {
sc = node;
var nodeLength = node.length;
so = sibling.length;
node.insertData(0, sibling.data);
removeNode(sibling);
if (sc == ec) {
eo += so;
ec = sc;
} else if (ec == node.parentNode) {
var nodeIndex = getNodeIndex(node);
if (eo == nodeIndex) {
ec = node;
eo = nodeLength;
} else if (eo > nodeIndex) {
eo--;
}
}
}
};var normalizeStart = true;
var sibling;if (isCharacterDataNode(ec)) {
if (eo == ec.length) {
mergeForward(ec);
} else if (eo == 0) {
sibling = ec.previousSibling;
if (sibling && sibling.nodeType == ec.nodeType) {
eo = sibling.length;
if (sc == ec) {
normalizeStart = false;
}
sibling.appendData(ec.data);
removeNode(ec);
ec = sibling;
}
}
} else {
if (eo > 0) {
var endNode = ec.childNodes[eo - 1];
if (endNode && isCharacterDataNode(endNode)) {
mergeForward(endNode);
}
}
normalizeStart = !this.collapsed;
}if (normalizeStart) {
if (isCharacterDataNode(sc)) {
if (so == 0) {
mergeBackward(sc);
} else if (so == sc.length) {
sibling = sc.nextSibling;
if (sibling && sibling.nodeType == sc.nodeType) {
if (ec == sibling) {
ec = sc;
eo += sc.length;
}
sc.appendData(sibling.data);
removeNode(sibling);
}
}
} else {
if (so < sc.childNodes.length) {
var startNode = sc.childNodes[so];
if (startNode && isCharacterDataNode(startNode)) {
mergeBackward(startNode);
}
}
}
} else {
sc = ec;
so = eo;
}boundaryUpdater(this, sc, so, ec, eo);
},collapseToPoint: function(node, offset) {
assertNoDocTypeNotationEntityAncestor(node, true);
assertValidOffset(node, offset);
this.setStartAndEnd(node, offset);
}
});copyComparisonConstants(constructor);
}/*----------------------------------------------------------------------------------------------------------------*/
function updateCollapsedAndCommonAncestor(range) {
range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);
range.commonAncestorContainer = range.collapsed ?
range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);
}function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {
range.startContainer = startContainer;
range.startOffset = startOffset;
range.endContainer = endContainer;
range.endOffset = endOffset;
range.document = dom.getDocument(startContainer);updateCollapsedAndCommonAncestor(range);
}function Range(doc) {
this.startContainer = doc;
this.startOffset = 0;
this.endContainer = doc;
this.endOffset = 0;
this.document = doc;
updateCollapsedAndCommonAncestor(this);
}createPrototypeRange(Range, updateBoundaries);util.extend(Range, {
rangeProperties: rangeProperties,
RangeIterator: RangeIterator,
copyComparisonConstants: copyComparisonConstants,
createPrototypeRange: createPrototypeRange,
inspect: inspect,
toHtml: rangeToHtml,
getRangeDocument: getRangeDocument,
rangesEqual: function(r1, r2) {
return r1.startContainer === r2.startContainer &&
r1.startOffset === r2.startOffset &&
r1.endContainer === r2.endContainer &&
r1.endOffset === r2.endOffset;
}
});api.DomRange = Range;
});/*----------------------------------------------------------------------------------------------------------------*/
api.createCoreModule("WrappedRange", ["DomRange"], function(api, module) {
var WrappedRange, WrappedTextRange;
var dom = api.dom;
var util = api.util;
var DomPosition = dom.DomPosition;
var DomRange = api.DomRange;
var getBody = dom.getBody;
var getContentDocument = dom.getContentDocument;
var isCharacterDataNode = dom.isCharacterDataNode;
/*----------------------------------------------------------------------------------------------------------------*/if (api.features.implementsDomRange) {
(function() {
var rangeProto;
var rangeProperties = DomRange.rangeProperties;function updateRangeProperties(range) {
var i = rangeProperties.length, prop;
while (i--) {
prop = rangeProperties[i];
range[prop] = range.nativeRange[prop];
}range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);
}function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {
var startMoved = (range.startContainer !== startContainer || range.startOffset != startOffset);
var endMoved = (range.endContainer !== endContainer || range.endOffset != endOffset);
var nativeRangeDifferent = !range.equals(range.nativeRange);
if (startMoved || endMoved || nativeRangeDifferent) {
range.setEnd(endContainer, endOffset);
range.setStart(startContainer, startOffset);
}
}var createBeforeAfterNodeSetter;WrappedRange = function(range) {
if (!range) {
throw module.createError("WrappedRange: Range must be specified");
}
this.nativeRange = range;
updateRangeProperties(this);
};DomRange.createPrototypeRange(WrappedRange, updateNativeRange);rangeProto = WrappedRange.prototype;rangeProto.selectNode = function(node) {
this.nativeRange.selectNode(node);
updateRangeProperties(this);
};rangeProto.cloneContents = function() {
return this.nativeRange.cloneContents();
};
rangeProto.surroundContents = function(node) {
this.nativeRange.surroundContents(node);
updateRangeProperties(this);
};rangeProto.collapse = function(isStart) {
this.nativeRange.collapse(isStart);
updateRangeProperties(this);
};rangeProto.cloneRange = function() {
return new WrappedRange(this.nativeRange.cloneRange());
};rangeProto.refresh = function() {
updateRangeProperties(this);
};rangeProto.toString = function() {
return this.nativeRange.toString();
};var testTextNode = document.createTextNode("test");
getBody(document).appendChild(testTextNode);
var range = document.createRange();/*--------------------------------------------------------------------------------------------------------*/
range.setStart(testTextNode, 0);
range.setEnd(testTextNode, 0);try {
range.setStart(testTextNode, 1);rangeProto.setStart = function(node, offset) {
this.nativeRange.setStart(node, offset);
updateRangeProperties(this);
};rangeProto.setEnd = function(node, offset) {
this.nativeRange.setEnd(node, offset);
updateRangeProperties(this);
};createBeforeAfterNodeSetter = function(name) {
return function(node) {
this.nativeRange[name](node);
updateRangeProperties(this);
};
};} catch(ex) {rangeProto.setStart = function(node, offset) {
try {
this.nativeRange.setStart(node, offset);
} catch (ex) {
this.nativeRange.setEnd(node, offset);
this.nativeRange.setStart(node, offset);
}
updateRangeProperties(this);
};rangeProto.setEnd = function(node, offset) {
try {
this.nativeRange.setEnd(node, offset);
} catch (ex) {
this.nativeRange.setStart(node, offset);
this.nativeRange.setEnd(node, offset);
}
updateRangeProperties(this);
};createBeforeAfterNodeSetter = function(name, oppositeName) {
return function(node) {
try {
this.nativeRange[name](node);
} catch (ex) {
this.nativeRange[oppositeName](node);
this.nativeRange[name](node);
}
updateRangeProperties(this);
};
};
}rangeProto.setStartBefore = createBeforeAfterNodeSetter("setStartBefore", "setEndBefore");
rangeProto.setStartAfter = createBeforeAfterNodeSetter("setStartAfter", "setEndAfter");
rangeProto.setEndBefore = createBeforeAfterNodeSetter("setEndBefore", "setStartBefore");
rangeProto.setEndAfter = createBeforeAfterNodeSetter("setEndAfter", "setStartAfter");/*--------------------------------------------------------------------------------------------------------*/rangeProto.selectNodeContents = function(node) {
this.setStartAndEnd(node, 0, dom.getNodeLength(node));
};/*--------------------------------------------------------------------------------------------------------*/
range.selectNodeContents(testTextNode);
range.setEnd(testTextNode, 3);var range2 = document.createRange();
range2.selectNodeContents(testTextNode);
range2.setEnd(testTextNode, 4);
range2.setStart(testTextNode, 2);if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 &&
range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {
rangeProto.compareBoundaryPoints = function(type, range) {
range = range.nativeRange || range;
if (type == range.START_TO_END) {
type = range.END_TO_START;
} else if (type == range.END_TO_START) {
type = range.START_TO_END;
}
return this.nativeRange.compareBoundaryPoints(type, range);
};
} else {
rangeProto.compareBoundaryPoints = function(type, range) {
return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);
};
}/*--------------------------------------------------------------------------------------------------------*/var el = document.createElement("div");
el.innerHTML = "123";
var textNode = el.firstChild;
var body = getBody(document);
body.appendChild(el);range.setStart(textNode, 1);
range.setEnd(textNode, 2);
range.deleteContents();if (textNode.data == "13") {
rangeProto.deleteContents = function() {
this.nativeRange.deleteContents();
updateRangeProperties(this);
};rangeProto.extractContents = function() {
var frag = this.nativeRange.extractContents();
updateRangeProperties(this);
return frag;
};
} else {
}body.removeChild(el);
body = null;/*--------------------------------------------------------------------------------------------------------*/
if (util.isHostMethod(range, "createContextualFragment")) {
rangeProto.createContextualFragment = function(fragmentStr) {
return this.nativeRange.createContextualFragment(fragmentStr);
};
}/*--------------------------------------------------------------------------------------------------------*/
getBody(document).removeChild(testTextNode);rangeProto.getName = function() {
return "WrappedRange";
};api.WrappedRange = WrappedRange;api.createNativeRange = function(doc) {
doc = getContentDocument(doc, module, "createNativeRange");
return doc.createRange();
};
})();
}if (api.features.implementsTextRange) {
/*
This is a workaround for a bug where IE returns the wrong container element from the TextRange's parentElement()
method. For example, in the following (where pipes denote the selection boundaries):<ul id="ul"><li id="a">| a </li><li id="b"> b |</li></ul>var range = document.selection.createRange();
alert(range.parentElement().id); This method returns the common ancestor node of the following:
- the parentElement() of the textRange
- the parentElement() of the textRange after calling collapse(true)
- the parentElement() of the textRange after calling collapse(false)
*/
var getTextRangeContainerElement = function(textRange) {
var parentEl = textRange.parentElement();
var range = textRange.duplicate();
range.collapse(true);
var startEl = range.parentElement();
range = textRange.duplicate();
range.collapse(false);
var endEl = range.parentElement();
var startEndContainer = (startEl == endEl) ? startEl : dom.getCommonAncestor(startEl, endEl);return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);
};var textRangeIsCollapsed = function(textRange) {
return textRange.compareEndPoints("StartToEnd", textRange) == 0;
};var getTextRangeBoundaryPosition = function(textRange, wholeRangeContainerElement, isStart, isCollapsed, startInfo) {
var workingRange = textRange.duplicate();
workingRange.collapse(isStart);
var containerElement = workingRange.parentElement();if (!dom.isOrIsAncestorOf(wholeRangeContainerElement, containerElement)) {
containerElement = wholeRangeContainerElement;
}
if (!containerElement.canHaveHTML) {
var pos = new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));
return {
boundaryPosition: pos,
nodeInfo: {
nodeIndex: pos.offset,
containerElement: pos.node
}
};
}var workingNode = dom.getDocument(containerElement).createElement("span");if (workingNode.parentNode) {
dom.removeNode(workingNode);
}var comparison, workingComparisonType = isStart ? "StartToStart" : "StartToEnd";
var previousNode, nextNode, boundaryPosition, boundaryNode;
var start = (startInfo && startInfo.containerElement == containerElement) ? startInfo.nodeIndex : 0;
var childNodeCount = containerElement.childNodes.length;
var end = childNodeCount;var nodeIndex = end;while (true) {
if (nodeIndex == childNodeCount) {
containerElement.appendChild(workingNode);
} else {
containerElement.insertBefore(workingNode, containerElement.childNodes[nodeIndex]);
}
workingRange.moveToElementText(workingNode);
comparison = workingRange.compareEndPoints(workingComparisonType, textRange);
if (comparison == 0 || start == end) {
break;
} else if (comparison == -1) {
if (end == start + 1) {break;
} else {
start = nodeIndex;
}
} else {
end = (end == start + 1) ? start : nodeIndex;
}
nodeIndex = Math.floor((start + end) / 2);
containerElement.removeChild(workingNode);
}
boundaryNode = workingNode.nextSibling;if (comparison == -1 && boundaryNode && isCharacterDataNode(boundaryNode)) {workingRange.setEndPoint(isStart ? "EndToStart" : "EndToEnd", textRange);var offset;if (/[\r\n]/.test(boundaryNode.data)) {
/*
For the particular case of a boundary within a text node containing rendered line breaks (within a
<pre> element, for example), we need a slightly complicated approach to get the boundary's offset in
IE. The facts:- Each line break is represented as \r in the text node's data/nodeValue properties
- Each line break is represented as \r\n in the TextRange's 'text' property
- The 'text' property of the TextRange does not contain trailing line breaksTo get round the problem presented by the final fact above, we can use the fact that TextRange's
moveStart() and moveEnd() methods return the actual number of characters moved, which is not
necessarily the same as the number of characters it was instructed to move. The simplest approach is
to use this to store the characters moved when moving both the start and end of the range to the
start of the document body and subtracting the start offset from the end offset (the
"move-negative-gazillion" method). However, this is extremely slow when the document is large and
the range is near the end of it. Clearly doing the mirror image (i.e. moving the range boundaries to
the end of the document) has the same problem.Another approach that works is to use moveStart() to move the start boundary of the range up to the
end boundary one character at a time and incrementing a counter with the value returned by the
moveStart() call. However, the check for whether the start boundary has reached the end boundary is
expensive, so this method is slow (although unlike "move-negative-gazillion" is largely unaffected
by the location of the range within the document).The approach used below is a hybrid of the two methods above. It uses the fact that a string
containing the TextRange's 'text' property with each \r\n converted to a single \r character cannot
be longer than the text of the TextRange, so the start of the range is moved that length initially
and then a character at a time to make up for any trailing line breaks not contained in the 'text'
property. This has good performance in most situations compared to the previous two methods.
*/
var tempRange = workingRange.duplicate();
var rangeLength = tempRange.text.replace(/\r\n/g, "\r").length;offset = tempRange.moveStart("character", rangeLength);
while ( (comparison = tempRange.compareEndPoints("StartToEnd", tempRange)) == -1) {
offset++;
tempRange.moveStart("character", 1);
}
} else {
offset = workingRange.text.length;
}
boundaryPosition = new DomPosition(boundaryNode, offset);
} else {previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;
nextNode = (isCollapsed || isStart) && workingNode.nextSibling;
if (nextNode && isCharacterDataNode(nextNode)) {
boundaryPosition = new DomPosition(nextNode, 0);
} else if (previousNode && isCharacterDataNode(previousNode)) {
boundaryPosition = new DomPosition(previousNode, previousNode.data.length);
} else {
boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));
}
}
dom.removeNode(workingNode);return {
boundaryPosition: boundaryPosition,
nodeInfo: {
nodeIndex: nodeIndex,
containerElement: containerElement
}
};
};
var createBoundaryTextRange = function(boundaryPosition, isStart) {
var boundaryNode, boundaryParent, boundaryOffset = boundaryPosition.offset;
var doc = dom.getDocument(boundaryPosition.node);
var workingNode, childNodes, workingRange = getBody(doc).createTextRange();
var nodeIsDataNode = isCharacterDataNode(boundaryPosition.node);if (nodeIsDataNode) {
boundaryNode = boundaryPosition.node;
boundaryParent = boundaryNode.parentNode;
} else {
childNodes = boundaryPosition.node.childNodes;
boundaryNode = (boundaryOffset < childNodes.length) ? childNodes[boundaryOffset] : null;
boundaryParent = boundaryPosition.node;
}
workingNode = doc.createElement("span");workingNode.innerHTML = "&#feff;";if (boundaryNode) {
boundaryParent.insertBefore(workingNode, boundaryNode);
} else {
boundaryParent.appendChild(workingNode);
}workingRange.moveToElementText(workingNode);
workingRange.collapse(!isStart);
boundaryParent.removeChild(workingNode);
if (nodeIsDataNode) {
workingRange[isStart ? "moveStart" : "moveEnd"]("character", boundaryOffset);
}return workingRange;
};/*------------------------------------------------------------------------------------------------------------*/
WrappedTextRange = function(textRange) {
this.textRange = textRange;
this.refresh();
};WrappedTextRange.prototype = new DomRange(document);WrappedTextRange.prototype.refresh = function() {
var start, end, startBoundary;
var rangeContainerElement = getTextRangeContainerElement(this.textRange);if (textRangeIsCollapsed(this.textRange)) {
end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true,
true).boundaryPosition;
} else {
startBoundary = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);
start = startBoundary.boundaryPosition;
end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false,
startBoundary.nodeInfo).boundaryPosition;
}this.setStart(start.node, start.offset);
this.setEnd(end.node, end.offset);
};WrappedTextRange.prototype.getName = function() {
return "WrappedTextRange";
};DomRange.copyComparisonConstants(WrappedTextRange);var rangeToTextRange = function(range) {
if (range.collapsed) {
return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
} else {
var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);
var textRange = getBody( DomRange.getRangeDocument(range) ).createTextRange();
textRange.setEndPoint("StartToStart", startRange);
textRange.setEndPoint("EndToEnd", endRange);
return textRange;
}
};WrappedTextRange.rangeToTextRange = rangeToTextRange;WrappedTextRange.prototype.toTextRange = function() {
return rangeToTextRange(this);
};api.WrappedTextRange = WrappedTextRange;if (!api.features.implementsDomRange || api.config.preferTextRange) {var globalObj = (function(f) { return f("return this;")(); })(Function);
if (typeof globalObj.Range == "undefined") {
globalObj.Range = WrappedTextRange;
}api.createNativeRange = function(doc) {
doc = getContentDocument(doc, module, "createNativeRange");
return getBody(doc).createTextRange();
};api.WrappedRange = WrappedTextRange;
}
}api.createRange = function(doc) {
doc = getContentDocument(doc, module, "createRange");
return new api.WrappedRange(api.createNativeRange(doc));
};api.createRangyRange = function(doc) {
doc = getContentDocument(doc, module, "createRangyRange");
return new DomRange(doc);
};util.createAliasForDeprecatedMethod(api, "createIframeRange", "createRange");
util.createAliasForDeprecatedMethod(api, "createIframeRangyRange", "createRangyRange");api.addShimListener(function(win) {
var doc = win.document;
if (typeof doc.createRange == "undefined") {
doc.createRange = function() {
return api.createRange(doc);
};
}
doc = win = null;
});
});/*----------------------------------------------------------------------------------------------------------------*/api.createCoreModule("WrappedSelection", ["DomRange", "WrappedRange"], function(api, module) {
api.config.checkSelectionRanges = true;var BOOLEAN = "boolean";
var NUMBER = "number";
var dom = api.dom;
var util = api.util;
var isHostMethod = util.isHostMethod;
var DomRange = api.DomRange;
var WrappedRange = api.WrappedRange;
var DOMException = api.DOMException;
var DomPosition = dom.DomPosition;
var getNativeSelection;
var selectionIsCollapsed;
var features = api.features;
var CONTROL = "Control";
var getDocument = dom.getDocument;
var getBody = dom.getBody;
var rangesEqual = DomRange.rangesEqual;
function isDirectionBackward(dir) {
return (typeof dir == "string") ? /^backward(s)?$/i.test(dir) : !!dir;
}function getWindow(win, methodName) {
if (!win) {
return window;
} else if (dom.isWindow(win)) {
return win;
} else if (win instanceof WrappedSelection) {
return win.win;
} else {
var doc = dom.getContentDocument(win, module, methodName);
return dom.getWindow(doc);
}
}function getWinSelection(winParam) {
return getWindow(winParam, "getWinSelection").getSelection();
}function getDocSelection(winParam) {
return getWindow(winParam, "getDocSelection").document.selection;
}function winSelectionIsBackward(sel) {
var backward = false;
if (sel.anchorNode) {
backward = (dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1);
}
return backward;
}var implementsWinGetSelection = isHostMethod(window, "getSelection"),
implementsDocSelection = util.isHostObject(document, "selection");features.implementsWinGetSelection = implementsWinGetSelection;
features.implementsDocSelection = implementsDocSelection;var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);if (useDocumentSelection) {
getNativeSelection = getDocSelection;
api.isSelectionValid = function(winParam) {
var doc = getWindow(winParam, "isSelectionValid").document, nativeSel = doc.selection;
return (nativeSel.type != "None" || getDocument(nativeSel.createRange().parentElement()) == doc);
};
} else if (implementsWinGetSelection) {
getNativeSelection = getWinSelection;
api.isSelectionValid = function() {
return true;
};
} else {
module.fail("Neither document.selection or window.getSelection() detected.");
return false;
}api.getNativeSelection = getNativeSelection;var testSelection = getNativeSelection();
if (!testSelection) {
module.fail("Native selection was null (possibly issue 138?)");
return false;
}var testRange = api.createNativeRange(document);
var body = getBody(document);
var selectionHasAnchorAndFocus = util.areHostProperties(testSelection,
["anchorNode", "focusNode", "anchorOffset", "focusOffset"]);features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;
var selectionHasExtend = isHostMethod(testSelection, "extend");
features.selectionHasExtend = selectionHasExtend;
var selectionHasRangeCount = (typeof testSelection.rangeCount == NUMBER);
features.selectionHasRangeCount = selectionHasRangeCount;var selectionSupportsMultipleRanges = false;
var collapsedNonEditableSelectionsSupported = true;var addRangeBackwardToNative = selectionHasExtend ?
function(nativeSelection, range) {
var doc = DomRange.getRangeDocument(range);
var endRange = api.createRange(doc);
endRange.collapseToPoint(range.endContainer, range.endOffset);
nativeSelection.addRange(getNativeRange(endRange));
nativeSelection.extend(range.startContainer, range.startOffset);
} : null;if (util.areHostMethods(testSelection, ["addRange", "getRangeAt", "removeAllRanges"]) &&
typeof testSelection.rangeCount == NUMBER && features.implementsDomRange) {(function() {
var sel = window.getSelection();
if (sel) {var originalSelectionRangeCount = sel.rangeCount;
var selectionHasMultipleRanges = (originalSelectionRangeCount > 1);
var originalSelectionRanges = [];
var originalSelectionBackward = winSelectionIsBackward(sel);
for (var i = 0; i < originalSelectionRangeCount; ++i) {
originalSelectionRanges[i] = sel.getRangeAt(i);
}
var testEl = dom.createTestElement(document, "", false);
var textNode = testEl.appendChild( document.createTextNode("\u00a0\u00a0\u00a0") );
var r1 = document.createRange();r1.setStart(textNode, 1);
r1.collapse(true);
sel.removeAllRanges();
sel.addRange(r1);
collapsedNonEditableSelectionsSupported = (sel.rangeCount == 1);
sel.removeAllRanges();
if (!selectionHasMultipleRanges) {var chromeMatch = window.navigator.appVersion.match(/Chrome\/(.*?) /);
if (chromeMatch && parseInt(chromeMatch[1]) >= 36) {
selectionSupportsMultipleRanges = false;
} else {
var r2 = r1.cloneRange();
r1.setStart(textNode, 0);
r2.setEnd(textNode, 3);
r2.setStart(textNode, 2);
sel.addRange(r1);
sel.addRange(r2);
selectionSupportsMultipleRanges = (sel.rangeCount == 2);
}
}
dom.removeNode(testEl);
sel.removeAllRanges();for (i = 0; i < originalSelectionRangeCount; ++i) {
if (i == 0 && originalSelectionBackward) {
if (addRangeBackwardToNative) {
addRangeBackwardToNative(sel, originalSelectionRanges[i]);
} else {
api.warn("Rangy initialization: original selection was backwards but selection has been restored forwards because the browser does not support Selection.extend");
sel.addRange(originalSelectionRanges[i]);
}
} else {
sel.addRange(originalSelectionRanges[i]);
}
}
}
})();
}features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;
features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;
var implementsControlRange = false, testControlRange;if (body && isHostMethod(body, "createControlRange")) {
testControlRange = body.createControlRange();
if (util.areHostProperties(testControlRange, ["item", "add"])) {
implementsControlRange = true;
}
}
features.implementsControlRange = implementsControlRange;
if (selectionHasAnchorAndFocus) {
selectionIsCollapsed = function(sel) {
return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;
};
} else {
selectionIsCollapsed = function(sel) {
return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;
};
}function updateAnchorAndFocusFromRange(sel, range, backward) {
var anchorPrefix = backward ? "end" : "start", focusPrefix = backward ? "start" : "end";
sel.anchorNode = range[anchorPrefix + "Container"];
sel.anchorOffset = range[anchorPrefix + "Offset"];
sel.focusNode = range[focusPrefix + "Container"];
sel.focusOffset = range[focusPrefix + "Offset"];
}function updateAnchorAndFocusFromNativeSelection(sel) {
var nativeSel = sel.nativeSelection;
sel.anchorNode = nativeSel.anchorNode;
sel.anchorOffset = nativeSel.anchorOffset;
sel.focusNode = nativeSel.focusNode;
sel.focusOffset = nativeSel.focusOffset;
}function updateEmptySelection(sel) {
sel.anchorNode = sel.focusNode = null;
sel.anchorOffset = sel.focusOffset = 0;
sel.rangeCount = 0;
sel.isCollapsed = true;
sel._ranges.length = 0;
}function getNativeRange(range) {
var nativeRange;
if (range instanceof DomRange) {
nativeRange = api.createNativeRange(range.getDocument());
nativeRange.setEnd(range.endContainer, range.endOffset);
nativeRange.setStart(range.startContainer, range.startOffset);
} else if (range instanceof WrappedRange) {
nativeRange = range.nativeRange;
} else if (features.implementsDomRange && (range instanceof dom.getWindow(range.startContainer).Range)) {
nativeRange = range;
}
return nativeRange;
}function rangeContainsSingleElement(rangeNodes) {
if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {
return false;
}
for (var i = 1, len = rangeNodes.length; i < len; ++i) {
if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {
return false;
}
}
return true;
}function getSingleElementFromRange(range) {
var nodes = range.getNodes();
if (!rangeContainsSingleElement(nodes)) {
throw module.createError("getSingleElementFromRange: range " + range.inspect() + " did not consist of a single element");
}
return nodes[0];
}
function isTextRange(range) {
return !!range && typeof range.text != "undefined";
}function updateFromTextRange(sel, range) {var wrappedRange = new WrappedRange(range);
sel._ranges = [wrappedRange];updateAnchorAndFocusFromRange(sel, wrappedRange, false);
sel.rangeCount = 1;
sel.isCollapsed = wrappedRange.collapsed;
}function updateControlSelection(sel) {sel._ranges.length = 0;
if (sel.docSelection.type == "None") {
updateEmptySelection(sel);
} else {
var controlRange = sel.docSelection.createRange();
if (isTextRange(controlRange)) {updateFromTextRange(sel, controlRange);
} else {
sel.rangeCount = controlRange.length;
var range, doc = getDocument(controlRange.item(0));
for (var i = 0; i < sel.rangeCount; ++i) {
range = api.createRange(doc);
range.selectNode(controlRange.item(i));
sel._ranges.push(range);
}
sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;
updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);
}
}
}function addRangeToControlSelection(sel, range) {
var controlRange = sel.docSelection.createRange();
var rangeElement = getSingleElementFromRange(range);var doc = getDocument(controlRange.item(0));
var newControlRange = getBody(doc).createControlRange();
for (var i = 0, len = controlRange.length; i < len; ++i) {
newControlRange.add(controlRange.item(i));
}
try {
newControlRange.add(rangeElement);
} catch (ex) {
throw module.createError("addRange(): Element within the specified Range could not be added to control selection (does it have layout?)");
}
newControlRange.select();
updateControlSelection(sel);
}var getSelectionRangeAt;if (isHostMethod(testSelection, "getRangeAt")) {getSelectionRangeAt = function(sel, index) {
try {
return sel.getRangeAt(index);
} catch (ex) {
return null;
}
};
} else if (selectionHasAnchorAndFocus) {
getSelectionRangeAt = function(sel) {
var doc = getDocument(sel.anchorNode);
var range = api.createRange(doc);
range.setStartAndEnd(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);if (range.collapsed !== this.isCollapsed) {
range.setStartAndEnd(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset);
}return range;
};
}function WrappedSelection(selection, docSelection, win) {
this.nativeSelection = selection;
this.docSelection = docSelection;
this._ranges = [];
this.win = win;
this.refresh();
}WrappedSelection.prototype = api.selectionPrototype;function deleteProperties(sel) {
sel.win = sel.anchorNode = sel.focusNode = sel._ranges = null;
sel.rangeCount = sel.anchorOffset = sel.focusOffset = 0;
sel.detached = true;
}var cachedRangySelections = [];function actOnCachedSelection(win, action) {
var i = cachedRangySelections.length, cached, sel;
while (i--) {
cached = cachedRangySelections[i];
sel = cached.selection;
if (action == "deleteAll") {
deleteProperties(sel);
} else if (cached.win == win) {
if (action == "delete") {
cachedRangySelections.splice(i, 1);
return true;
} else {
return sel;
}
}
}
if (action == "deleteAll") {
cachedRangySelections.length = 0;
}
return null;
}var getSelection = function(win) {if (win && win instanceof WrappedSelection) {
win.refresh();
return win;
}win = getWindow(win, "getNativeSelection");var sel = actOnCachedSelection(win);
var nativeSel = getNativeSelection(win), docSel = implementsDocSelection ? getDocSelection(win) : null;
if (sel) {
sel.nativeSelection = nativeSel;
sel.docSelection = docSel;
sel.refresh();
} else {
sel = new WrappedSelection(nativeSel, docSel, win);
cachedRangySelections.push( { win: win, selection: sel } );
}
return sel;
};api.getSelection = getSelection;util.createAliasForDeprecatedMethod(api, "getIframeSelection", "getSelection");var selProto = WrappedSelection.prototype;function createControlSelection(sel, ranges) {var doc = getDocument(ranges[0].startContainer);
var controlRange = getBody(doc).createControlRange();
for (var i = 0, el, len = ranges.length; i < len; ++i) {
el = getSingleElementFromRange(ranges[i]);
try {
controlRange.add(el);
} catch (ex) {
throw module.createError("setRanges(): Element within one of the specified Ranges could not be added to control selection (does it have layout?)");
}
}
controlRange.select();
updateControlSelection(sel);
}
if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, ["removeAllRanges", "addRange"])) {
selProto.removeAllRanges = function() {
this.nativeSelection.removeAllRanges();
updateEmptySelection(this);
};var addRangeBackward = function(sel, range) {
addRangeBackwardToNative(sel.nativeSelection, range);
sel.refresh();
};if (selectionHasRangeCount) {
selProto.addRange = function(range, direction) {
if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
addRangeToControlSelection(this, range);
} else {
if (isDirectionBackward(direction) && selectionHasExtend) {
addRangeBackward(this, range);
} else {
var previousRangeCount;
if (selectionSupportsMultipleRanges) {
previousRangeCount = this.rangeCount;
} else {
this.removeAllRanges();
previousRangeCount = 0;
}var clonedNativeRange = getNativeRange(range).cloneRange();
try {
this.nativeSelection.addRange(clonedNativeRange);
} catch (ex) {
}
this.rangeCount = this.nativeSelection.rangeCount;if (this.rangeCount == previousRangeCount + 1) {
if (api.config.checkSelectionRanges) {
var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);
if (nativeRange && !rangesEqual(nativeRange, range)) {range = new WrappedRange(nativeRange);
}
}
this._ranges[this.rangeCount - 1] = range;
updateAnchorAndFocusFromRange(this, range, selectionIsBackward(this.nativeSelection));
this.isCollapsed = selectionIsCollapsed(this);
} else {this.refresh();
}
}
}
};
} else {
selProto.addRange = function(range, direction) {
if (isDirectionBackward(direction) && selectionHasExtend) {
addRangeBackward(this, range);
} else {
this.nativeSelection.addRange(getNativeRange(range));
this.refresh();
}
};
}selProto.setRanges = function(ranges) {
if (implementsControlRange && implementsDocSelection && ranges.length > 1) {
createControlSelection(this, ranges);
} else {
this.removeAllRanges();
for (var i = 0, len = ranges.length; i < len; ++i) {
this.addRange(ranges[i]);
}
}
};
} else if (isHostMethod(testSelection, "empty") && isHostMethod(testRange, "select") &&
 implementsControlRange && useDocumentSelection) {selProto.removeAllRanges = function() {try {
this.docSelection.empty();
if (this.docSelection.type != "None") {
var doc;
if (this.anchorNode) {
doc = getDocument(this.anchorNode);
} else if (this.docSelection.type == CONTROL) {
var controlRange = this.docSelection.createRange();
if (controlRange.length) {
doc = getDocument( controlRange.item(0) );
}
}
if (doc) {
var textRange = getBody(doc).createTextRange();
textRange.select();
this.docSelection.empty();
}
}
} catch(ex) {}
updateEmptySelection(this);
};selProto.addRange = function(range) {
if (this.docSelection.type == CONTROL) {
addRangeToControlSelection(this, range);
} else {
api.WrappedTextRange.rangeToTextRange(range).select();
this._ranges[0] = range;
this.rangeCount = 1;
this.isCollapsed = this._ranges[0].collapsed;
updateAnchorAndFocusFromRange(this, range, false);
}
};selProto.setRanges = function(ranges) {
this.removeAllRanges();
var rangeCount = ranges.length;
if (rangeCount > 1) {
createControlSelection(this, ranges);
} else if (rangeCount) {
this.addRange(ranges[0]);
}
};
} else {
module.fail("No means of selecting a Range or TextRange was found");
return false;
}selProto.getRangeAt = function(index) {
if (index < 0 || index >= this.rangeCount) {
throw new DOMException("INDEX_SIZE_ERR");
} else {return this._ranges[index].cloneRange();
}
};var refreshSelection;if (useDocumentSelection) {
refreshSelection = function(sel) {
var range;
if (api.isSelectionValid(sel.win)) {
range = sel.docSelection.createRange();
} else {
range = getBody(sel.win.document).createTextRange();
range.collapse(true);
}if (sel.docSelection.type == CONTROL) {
updateControlSelection(sel);
} else if (isTextRange(range)) {
updateFromTextRange(sel, range);
} else {
updateEmptySelection(sel);
}
};
} else if (isHostMethod(testSelection, "getRangeAt") && typeof testSelection.rangeCount == NUMBER) {
refreshSelection = function(sel) {
if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {
updateControlSelection(sel);
} else {
sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;
if (sel.rangeCount) {
for (var i = 0, len = sel.rangeCount; i < len; ++i) {
sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));
}
updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackward(sel.nativeSelection));
sel.isCollapsed = selectionIsCollapsed(sel);
} else {
updateEmptySelection(sel);
}
}
};
} else if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && features.implementsDomRange) {
refreshSelection = function(sel) {
var range, nativeSel = sel.nativeSelection;
if (nativeSel.anchorNode) {
range = getSelectionRangeAt(nativeSel, 0);
sel._ranges = [range];
sel.rangeCount = 1;
updateAnchorAndFocusFromNativeSelection(sel);
sel.isCollapsed = selectionIsCollapsed(sel);
} else {
updateEmptySelection(sel);
}
};
} else {
module.fail("No means of obtaining a Range or TextRange from the user's selection was found");
return false;
}selProto.refresh = function(checkForChanges) {
var oldRanges = checkForChanges ? this._ranges.slice(0) : null;
var oldAnchorNode = this.anchorNode, oldAnchorOffset = this.anchorOffset;refreshSelection(this);
if (checkForChanges) {var i = oldRanges.length;
if (i != this._ranges.length) {
return true;
}if (this.anchorNode != oldAnchorNode || this.anchorOffset != oldAnchorOffset) {
return true;
}
while (i--) {
if (!rangesEqual(oldRanges[i], this._ranges[i])) {
return true;
}
}
return false;
}
};
var removeRangeManually = function(sel, range) {
var ranges = sel.getAllRanges();
sel.removeAllRanges();
for (var i = 0, len = ranges.length; i < len; ++i) {
if (!rangesEqual(range, ranges[i])) {
sel.addRange(ranges[i]);
}
}
if (!sel.rangeCount) {
updateEmptySelection(sel);
}
};if (implementsControlRange && implementsDocSelection) {
selProto.removeRange = function(range) {
if (this.docSelection.type == CONTROL) {
var controlRange = this.docSelection.createRange();
var rangeElement = getSingleElementFromRange(range);var doc = getDocument(controlRange.item(0));
var newControlRange = getBody(doc).createControlRange();
var el, removed = false;
for (var i = 0, len = controlRange.length; i < len; ++i) {
el = controlRange.item(i);
if (el !== rangeElement || removed) {
newControlRange.add(controlRange.item(i));
} else {
removed = true;
}
}
newControlRange.select();
updateControlSelection(this);
} else {
removeRangeManually(this, range);
}
};
} else {
selProto.removeRange = function(range) {
removeRangeManually(this, range);
};
}
var selectionIsBackward;
if (!useDocumentSelection && selectionHasAnchorAndFocus && features.implementsDomRange) {
selectionIsBackward = winSelectionIsBackward;selProto.isBackward = function() {
return selectionIsBackward(this);
};
} else {
selectionIsBackward = selProto.isBackward = function() {
return false;
};
}
selProto.isBackwards = selProto.isBackward;
selProto.toString = function() {
var rangeTexts = [];
for (var i = 0, len = this.rangeCount; i < len; ++i) {
rangeTexts[i] = "" + this._ranges[i];
}
return rangeTexts.join("");
};function assertNodeInSameDocument(sel, node) {
if (sel.win.document != getDocument(node)) {
throw new DOMException("WRONG_DOCUMENT_ERR");
}
}
selProto.collapse = function(node, offset) {
assertNodeInSameDocument(this, node);
var range = api.createRange(node);
range.collapseToPoint(node, offset);
this.setSingleRange(range);
this.isCollapsed = true;
};selProto.collapseToStart = function() {
if (this.rangeCount) {
var range = this._ranges[0];
this.collapse(range.startContainer, range.startOffset);
} else {
throw new DOMException("INVALID_STATE_ERR");
}
};selProto.collapseToEnd = function() {
if (this.rangeCount) {
var range = this._ranges[this.rangeCount - 1];
this.collapse(range.endContainer, range.endOffset);
} else {
throw new DOMException("INVALID_STATE_ERR");
}
};selProto.selectAllChildren = function(node) {
assertNodeInSameDocument(this, node);
var range = api.createRange(node);
range.selectNodeContents(node);
this.setSingleRange(range);
};selProto.deleteFromDocument = function() {if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
var controlRange = this.docSelection.createRange();
var element;
while (controlRange.length) {
element = controlRange.item(0);
controlRange.remove(element);
dom.removeNode(element);
}
this.refresh();
} else if (this.rangeCount) {
var ranges = this.getAllRanges();
if (ranges.length) {
this.removeAllRanges();
for (var i = 0, len = ranges.length; i < len; ++i) {
ranges[i].deleteContents();
}
this.addRange(ranges[len - 1]);
}
}
};
selProto.eachRange = function(func, returnValue) {
for (var i = 0, len = this._ranges.length; i < len; ++i) {
if ( func( this.getRangeAt(i) ) ) {
return returnValue;
}
}
};selProto.getAllRanges = function() {
var ranges = [];
this.eachRange(function(range) {
ranges.push(range);
});
return ranges;
};selProto.setSingleRange = function(range, direction) {
this.removeAllRanges();
this.addRange(range, direction);
};selProto.callMethodOnEachRange = function(methodName, params) {
var results = [];
this.eachRange( function(range) {
results.push( range[methodName].apply(range, params || []) );
} );
return results;
};function createStartOrEndSetter(isStart) {
return function(node, offset) {
var range;
if (this.rangeCount) {
range = this.getRangeAt(0);
range["set" + (isStart ? "Start" : "End")](node, offset);
} else {
range = api.createRange(this.win.document);
range.setStartAndEnd(node, offset);
}
this.setSingleRange(range, this.isBackward());
};
}selProto.setStart = createStartOrEndSetter(true);
selProto.setEnd = createStartOrEndSetter(false);
api.rangePrototype.select = function(direction) {
getSelection( this.getDocument() ).setSingleRange(this, direction);
};selProto.changeEachRange = function(func) {
var ranges = [];
var backward = this.isBackward();this.eachRange(function(range) {
func(range);
ranges.push(range);
});this.removeAllRanges();
if (backward && ranges.length == 1) {
this.addRange(ranges[0], "backward");
} else {
this.setRanges(ranges);
}
};selProto.containsNode = function(node, allowPartial) {
return this.eachRange( function(range) {
return range.containsNode(node, allowPartial);
}, true ) || false;
};selProto.getBookmark = function(containerNode) {
return {
backward: this.isBackward(),
rangeBookmarks: this.callMethodOnEachRange("getBookmark", [containerNode])
};
};selProto.moveToBookmark = function(bookmark) {
var selRanges = [];
for (var i = 0, rangeBookmark, range; rangeBookmark = bookmark.rangeBookmarks[i++]; ) {
range = api.createRange(this.win);
range.moveToBookmark(rangeBookmark);
selRanges.push(range);
}
if (bookmark.backward) {
this.setSingleRange(selRanges[0], "backward");
} else {
this.setRanges(selRanges);
}
};selProto.saveRanges = function() {
return {
backward: this.isBackward(),
ranges: this.callMethodOnEachRange("cloneRange")
};
};selProto.restoreRanges = function(selRanges) {
this.removeAllRanges();
for (var i = 0, range; range = selRanges.ranges[i]; ++i) {
this.addRange(range, (selRanges.backward && i == 0));
}
};selProto.toHtml = function() {
var rangeHtmls = [];
this.eachRange(function(range) {
rangeHtmls.push( DomRange.toHtml(range) );
});
return rangeHtmls.join("");
};if (features.implementsTextRange) {
selProto.getNativeTextRange = function() {
var sel, textRange;
if ( (sel = this.docSelection) ) {
var range = sel.createRange();
if (isTextRange(range)) {
return range;
} else {
throw module.createError("getNativeTextRange: selection is a control selection");
}
} else if (this.rangeCount > 0) {
return api.WrappedTextRange.rangeToTextRange( this.getRangeAt(0) );
} else {
throw module.createError("getNativeTextRange: selection contains no range");
}
};
}function inspect(sel) {
var rangeInspects = [];
var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);
var focus = new DomPosition(sel.focusNode, sel.focusOffset);
var name = (typeof sel.getName == "function") ? sel.getName() : "Selection";if (typeof sel.rangeCount != "undefined") {
for (var i = 0, len = sel.rangeCount; i < len; ++i) {
rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));
}
}
return "[" + name + "(Ranges: " + rangeInspects.join(", ") +
")(anchor: " + anchor.inspect() + ", focus: " + focus.inspect() + "]";
}selProto.getName = function() {
return "WrappedSelection";
};selProto.inspect = function() {
return inspect(this);
};selProto.detach = function() {
actOnCachedSelection(this.win, "delete");
deleteProperties(this);
};WrappedSelection.detachAll = function() {
actOnCachedSelection(null, "deleteAll");
};WrappedSelection.inspect = inspect;
WrappedSelection.isDirectionBackward = isDirectionBackward;api.Selection = WrappedSelection;api.selectionPrototype = selProto;api.addShimListener(function(win) {
if (typeof win.getSelection == "undefined") {
win.getSelection = function() {
return getSelection(win);
};
}
win = null;
});
});
/*----------------------------------------------------------------------------------------------------------------*/
var docReady = false;var loadHandler = function(e) {
if (!docReady) {
docReady = true;
if (!api.initialized && api.config.autoInitialize) {
init();
}
}
};if (isBrowser) {if (document.readyState == "complete") {
loadHandler();
} else {
if (isHostMethod(document, "addEventListener")) {
document.addEventListener("DOMContentLoaded", loadHandler, false);
}
addListener(window, "load", loadHandler);
}
}return api;
}, this);
(function(factory, root) {
if (typeof define == "function" && define.amd) {define(["./rangy-core"], factory);
} else if (typeof module != "undefined" && typeof exports == "object") {module.exports = factory( require("rangy") );
} else {factory(root.rangy);
}
})(function(rangy) {
rangy.createModule("ClassApplier", ["WrappedSelection"], function(api, module) {
var dom = api.dom;
var DomPosition = dom.DomPosition;
var contains = dom.arrayContains;
var util = api.util;
var forEach = util.forEach;
var defaultTagName = "span";
var createElementNSSupported = util.isHostMethod(document, "createElementNS");function each(obj, func) {
for (var i in obj) {
if (obj.hasOwnProperty(i)) {
if (func(i, obj[i]) === false) {
return false;
}
}
}
return true;
}function trim(str) {
return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}function classNameContainsClass(fullClassName, className) {
return !!fullClassName && new RegExp("(?:^|\\s)" + className + "(?:\\s|$)").test(fullClassName);
}
function hasClass(el, className) {
if (typeof el.classList == "object") {
return el.classList.contains(className);
} else {
var classNameSupported = (typeof el.className == "string");
var elClass = classNameSupported ? el.className : el.getAttribute("class");
return classNameContainsClass(elClass, className);
}
}function addClass(el, className) {
if (typeof el.classList == "object") {
el.classList.add(className);
} else {
var classNameSupported = (typeof el.className == "string");
var elClass = classNameSupported ? el.className : el.getAttribute("class");
if (elClass) {
if (!classNameContainsClass(elClass, className)) {
elClass += " " + className;
}
} else {
elClass = className;
}
if (classNameSupported) {
el.className = elClass;
} else {
el.setAttribute("class", elClass);
}
}
}var removeClass = (function() {
function replacer(matched, whiteSpaceBefore, whiteSpaceAfter) {
return (whiteSpaceBefore && whiteSpaceAfter) ? " " : "";
}return function(el, className) {
if (typeof el.classList == "object") {
el.classList.remove(className);
} else {
var classNameSupported = (typeof el.className == "string");
var elClass = classNameSupported ? el.className : el.getAttribute("class");
elClass = elClass.replace(new RegExp("(^|\\s)" + className + "(\\s|$)"), replacer);
if (classNameSupported) {
el.className = elClass;
} else {
el.setAttribute("class", elClass);
}
}
};
})();function getClass(el) {
var classNameSupported = (typeof el.className == "string");
return classNameSupported ? el.className : el.getAttribute("class");
}function sortClassName(className) {
return className && className.split(/\s+/).sort().join(" ");
}function getSortedClassName(el) {
return sortClassName( getClass(el) );
}function haveSameClasses(el1, el2) {
return getSortedClassName(el1) == getSortedClassName(el2);
}function hasAllClasses(el, className) {
var classes = className.split(/\s+/);
for (var i = 0, len = classes.length; i < len; ++i) {
if (!hasClass(el, trim(classes[i]))) {
return false;
}
}
return true;
}function canTextBeStyled(textNode) {
var parent = textNode.parentNode;
return (parent && parent.nodeType == 1 && !/^(textarea|style|script|select|iframe)$/i.test(parent.nodeName));
}function movePosition(position, oldParent, oldIndex, newParent, newIndex) {
var posNode = position.node, posOffset = position.offset;
var newNode = posNode, newOffset = posOffset;if (posNode == newParent && posOffset > newIndex) {
++newOffset;
}if (posNode == oldParent && (posOffset == oldIndex|| posOffset == oldIndex + 1)) {
newNode = newParent;
newOffset += newIndex - oldIndex;
}if (posNode == oldParent && posOffset > oldIndex + 1) {
--newOffset;
}position.node = newNode;
position.offset = newOffset;
}function movePositionWhenRemovingNode(position, parentNode, index) {
if (position.node == parentNode && position.offset > index) {
--position.offset;
}
}function movePreservingPositions(node, newParent, newIndex, positionsToPreserve) {if (newIndex == -1) {
newIndex = newParent.childNodes.length;
}var oldParent = node.parentNode;
var oldIndex = dom.getNodeIndex(node);forEach(positionsToPreserve, function(position) {
movePosition(position, oldParent, oldIndex, newParent, newIndex);
});
if (newParent.childNodes.length == newIndex) {
newParent.appendChild(node);
} else {
newParent.insertBefore(node, newParent.childNodes[newIndex]);
}
}function removePreservingPositions(node, positionsToPreserve) {var oldParent = node.parentNode;
var oldIndex = dom.getNodeIndex(node);forEach(positionsToPreserve, function(position) {
movePositionWhenRemovingNode(position, oldParent, oldIndex);
});dom.removeNode(node);
}function moveChildrenPreservingPositions(node, newParent, newIndex, removeNode, positionsToPreserve) {
var child, children = [];
while ( (child = node.firstChild) ) {
movePreservingPositions(child, newParent, newIndex++, positionsToPreserve);
children.push(child);
}
if (removeNode) {
removePreservingPositions(node, positionsToPreserve);
}
return children;
}function replaceWithOwnChildrenPreservingPositions(element, positionsToPreserve) {
return moveChildrenPreservingPositions(element, element.parentNode, dom.getNodeIndex(element), true, positionsToPreserve);
}function rangeSelectsAnyText(range, textNode) {
var textNodeRange = range.cloneRange();
textNodeRange.selectNodeContents(textNode);var intersectionRange = textNodeRange.intersection(range);
var text = intersectionRange ? intersectionRange.toString() : "";return text != "";
}function getEffectiveTextNodes(range) {
var nodes = range.getNodes([3]);
var start = 0, node;
while ( (node = nodes[start]) && !rangeSelectsAnyText(range, node) ) {
++start;
}
var end = nodes.length - 1;
while ( (node = nodes[end]) && !rangeSelectsAnyText(range, node) ) {
--end;
}return nodes.slice(start, end + 1);
}function elementsHaveSameNonClassAttributes(el1, el2) {
if (el1.attributes.length != el2.attributes.length) return false;
for (var i = 0, len = el1.attributes.length, attr1, attr2, name; i < len; ++i) {
attr1 = el1.attributes[i];
name = attr1.name;
if (name != "class") {
attr2 = el2.attributes.getNamedItem(name);
if ( (attr1 === null) != (attr2 === null) ) return false;
if (attr1.specified != attr2.specified) return false;
if (attr1.specified && attr1.nodeValue !== attr2.nodeValue) return false;
}
}
return true;
}function elementHasNonClassAttributes(el, exceptions) {
for (var i = 0, len = el.attributes.length, attrName; i < len; ++i) {
attrName = el.attributes[i].name;
if ( !(exceptions && contains(exceptions, attrName)) && el.attributes[i].specified && attrName != "class") {
return true;
}
}
return false;
}var getComputedStyleProperty = dom.getComputedStyleProperty;
var isEditableElement = (function() {
var testEl = document.createElement("div");
return typeof testEl.isContentEditable == "boolean" ?
function (node) {
return node && node.nodeType == 1 && node.isContentEditable;
} :
function (node) {
if (!node || node.nodeType != 1 || node.contentEditable == "false") {
return false;
}
return node.contentEditable == "true" || isEditableElement(node.parentNode);
};
})();function isEditingHost(node) {
var parent;
return node && node.nodeType == 1 &&
(( (parent = node.parentNode) && parent.nodeType == 9 && parent.designMode == "on") ||
(isEditableElement(node) && !isEditableElement(node.parentNode)));
}function isEditable(node) {
return (isEditableElement(node) || (node.nodeType != 1 && isEditableElement(node.parentNode))) && !isEditingHost(node);
}var inlineDisplayRegex = /^inline(-block|-table)?$/i;function isNonInlineElement(node) {
return node && node.nodeType == 1 && !inlineDisplayRegex.test(getComputedStyleProperty(node, "display"));
}
var htmlNonWhiteSpaceRegex = /[^\r\n\t\f \u200B]/;function isUnrenderedWhiteSpaceNode(node) {
if (node.data.length == 0) {
return true;
}
if (htmlNonWhiteSpaceRegex.test(node.data)) {
return false;
}
var cssWhiteSpace = getComputedStyleProperty(node.parentNode, "whiteSpace");
switch (cssWhiteSpace) {
case "pre":
case "pre-wrap":
case "-moz-pre-wrap":
return false;
case "pre-line":
if (/[\r\n]/.test(node.data)) {
return false;
}
}return isNonInlineElement(node.previousSibling) || isNonInlineElement(node.nextSibling);
}function getRangeBoundaries(ranges) {
var positions = [], i, range;
for (i = 0; range = ranges[i++]; ) {
positions.push(
new DomPosition(range.startContainer, range.startOffset),
new DomPosition(range.endContainer, range.endOffset)
);
}
return positions;
}function updateRangesFromBoundaries(ranges, positions) {
for (var i = 0, range, start, end, len = ranges.length; i < len; ++i) {
range = ranges[i];
start = positions[i * 2];
end = positions[i * 2 + 1];
range.setStartAndEnd(start.node, start.offset, end.node, end.offset);
}
}function isSplitPoint(node, offset) {
if (dom.isCharacterDataNode(node)) {
if (offset == 0) {
return !!node.previousSibling;
} else if (offset == node.length) {
return !!node.nextSibling;
} else {
return true;
}
}return offset > 0 && offset < node.childNodes.length;
}function splitNodeAt(node, descendantNode, descendantOffset, positionsToPreserve) {
var newNode, parentNode;
var splitAtStart = (descendantOffset == 0);if (dom.isAncestorOf(descendantNode, node)) {
return node;
}if (dom.isCharacterDataNode(descendantNode)) {
var descendantIndex = dom.getNodeIndex(descendantNode);
if (descendantOffset == 0) {
descendantOffset = descendantIndex;
} else if (descendantOffset == descendantNode.length) {
descendantOffset = descendantIndex + 1;
} else {
throw module.createError("splitNodeAt() should not be called with offset in the middle of a data node (" +
descendantOffset + " in " + descendantNode.data);
}
descendantNode = descendantNode.parentNode;
}if (isSplitPoint(descendantNode, descendantOffset)) {newNode = descendantNode.cloneNode(false);
parentNode = descendantNode.parentNode;
if (newNode.id) {
newNode.removeAttribute("id");
}
var child, newChildIndex = 0;while ( (child = descendantNode.childNodes[descendantOffset]) ) {
movePreservingPositions(child, newNode, newChildIndex++, positionsToPreserve);
}
movePreservingPositions(newNode, parentNode, dom.getNodeIndex(descendantNode) + 1, positionsToPreserve);
return (descendantNode == node) ? newNode : splitNodeAt(node, parentNode, dom.getNodeIndex(newNode), positionsToPreserve);
} else if (node != descendantNode) {
newNode = descendantNode.parentNode;
var newNodeIndex = dom.getNodeIndex(descendantNode);if (!splitAtStart) {
newNodeIndex++;
}
return splitNodeAt(node, newNode, newNodeIndex, positionsToPreserve);
}
return node;
}function areElementsMergeable(el1, el2) {
return el1.namespaceURI == el2.namespaceURI &&
el1.tagName.toLowerCase() == el2.tagName.toLowerCase() &&
haveSameClasses(el1, el2) &&
elementsHaveSameNonClassAttributes(el1, el2) &&
getComputedStyleProperty(el1, "display") == "inline" &&
getComputedStyleProperty(el2, "display") == "inline";
}function createAdjacentMergeableTextNodeGetter(forward) {
var siblingPropName = forward ? "nextSibling" : "previousSibling";return function(textNode, checkParentElement) {
var el = textNode.parentNode;
var adjacentNode = textNode[siblingPropName];
if (adjacentNode) {if (adjacentNode && adjacentNode.nodeType == 3) {
return adjacentNode;
}
} else if (checkParentElement) {adjacentNode = el[siblingPropName];
if (adjacentNode && adjacentNode.nodeType == 1 && areElementsMergeable(el, adjacentNode)) {
var adjacentNodeChild = adjacentNode[forward ? "firstChild" : "lastChild"];
if (adjacentNodeChild && adjacentNodeChild.nodeType == 3) {
return adjacentNodeChild;
}
}
}
return null;
};
}var getPreviousMergeableTextNode = createAdjacentMergeableTextNodeGetter(false),
getNextMergeableTextNode = createAdjacentMergeableTextNodeGetter(true);
function Merge(firstNode) {
this.isElementMerge = (firstNode.nodeType == 1);
this.textNodes = [];
var firstTextNode = this.isElementMerge ? firstNode.lastChild : firstNode;
if (firstTextNode) {
this.textNodes[0] = firstTextNode;
}
}Merge.prototype = {
doMerge: function(positionsToPreserve) {
var textNodes = this.textNodes;
var firstTextNode = textNodes[0];
if (textNodes.length > 1) {
var firstTextNodeIndex = dom.getNodeIndex(firstTextNode);
var textParts = [], combinedTextLength = 0, textNode, parent;
forEach(textNodes, function(textNode, i) {
parent = textNode.parentNode;
if (i > 0) {
parent.removeChild(textNode);
if (!parent.hasChildNodes()) {
dom.removeNode(parent);
}
if (positionsToPreserve) {
forEach(positionsToPreserve, function(position) {if (position.node == textNode) {
position.node = firstTextNode;
position.offset += combinedTextLength;
}if (position.node == parent && position.offset > firstTextNodeIndex) {
--position.offset;
if (position.offset == firstTextNodeIndex + 1 && i < len - 1) {
position.node = firstTextNode;
position.offset = combinedTextLength;
}
}
});
}
}
textParts[i] = textNode.data;
combinedTextLength += textNode.data.length;
});
firstTextNode.data = textParts.join("");
}
return firstTextNode.data;
},getLength: function() {
var i = this.textNodes.length, len = 0;
while (i--) {
len += this.textNodes[i].length;
}
return len;
},toString: function() {
var textParts = [];
forEach(this.textNodes, function(textNode, i) {
textParts[i] = "'" + textNode.data + "'";
});
return "[Merge(" + textParts.join(",") + ")]";
}
};var optionProperties = ["elementTagName", "ignoreWhiteSpace", "applyToEditableOnly", "useExistingElements",
"removeEmptyElements", "onElementCreate"];
var attrNamesForProperties = {};function ClassApplier(className, options, tagNames) {
var normalize, i, len, propName, applier = this;
applier.cssClass = applier.className = className; var elementPropertiesFromOptions = null, elementAttributes = {};
if (typeof options == "object" && options !== null) {
if (typeof options.elementTagName !== "undefined") {
options.elementTagName = options.elementTagName.toLowerCase();
}
tagNames = options.tagNames;
elementPropertiesFromOptions = options.elementProperties;
elementAttributes = options.elementAttributes;for (i = 0; propName = optionProperties[i++]; ) {
if (options.hasOwnProperty(propName)) {
applier[propName] = options[propName];
}
}
normalize = options.normalize;
} else {
normalize = options;
}
applier.normalize = (typeof normalize == "undefined") ? true : normalize;
applier.attrExceptions = [];
var el = document.createElement(applier.elementTagName);
applier.elementProperties = applier.copyPropertiesToElement(elementPropertiesFromOptions, el, true);
each(elementAttributes, function(attrName, attrValue) {
applier.attrExceptions.push(attrName);elementAttributes[attrName] = "" + attrValue;
});
applier.elementAttributes = elementAttributes;applier.elementSortedClassName = applier.elementProperties.hasOwnProperty("className") ?
sortClassName(applier.elementProperties.className + " " + className) : className;
applier.applyToAnyTagName = false;
var type = typeof tagNames;
if (type == "string") {
if (tagNames == "*") {
applier.applyToAnyTagName = true;
} else {
applier.tagNames = trim(tagNames.toLowerCase()).split(/\s*,\s*/);
}
} else if (type == "object" && typeof tagNames.length == "number") {
applier.tagNames = [];
for (i = 0, len = tagNames.length; i < len; ++i) {
if (tagNames[i] == "*") {
applier.applyToAnyTagName = true;
} else {
applier.tagNames.push(tagNames[i].toLowerCase());
}
}
} else {
applier.tagNames = [applier.elementTagName];
}
}ClassApplier.prototype = {
elementTagName: defaultTagName,
elementProperties: {},
elementAttributes: {},
ignoreWhiteSpace: true,
applyToEditableOnly: false,
useExistingElements: true,
removeEmptyElements: true,
onElementCreate: null,copyPropertiesToElement: function(props, el, createCopy) {
var s, elStyle, elProps = {}, elPropsStyle, propValue, elPropValue, attrName;for (var p in props) {
if (props.hasOwnProperty(p)) {
propValue = props[p];
elPropValue = el[p];if (p == "className") {
addClass(el, propValue);
addClass(el, this.className);
el[p] = sortClassName(el[p]);
if (createCopy) {
elProps[p] = propValue;
}
}
else if (p == "style") {
elStyle = elPropValue;
if (createCopy) {
elProps[p] = elPropsStyle = {};
}
for (s in props[p]) {
if (props[p].hasOwnProperty(s)) {
elStyle[s] = propValue[s];
if (createCopy) {
elPropsStyle[s] = elStyle[s];
}
}
}
this.attrExceptions.push(p);
} else {
el[p] = propValue;
if (createCopy) {
elProps[p] = el[p];
attrName = attrNamesForProperties.hasOwnProperty(p) ? attrNamesForProperties[p] : p;
this.attrExceptions.push(attrName);
}
}
}
}return createCopy ? elProps : "";
},copyAttributesToElement: function(attrs, el) {
for (var attrName in attrs) {
if (attrs.hasOwnProperty(attrName) && !/^class(?:Name)?$/i.test(attrName)) {
el.setAttribute(attrName, attrs[attrName]);
}
}
},appliesToElement: function(el) {
return contains(this.tagNames, el.tagName.toLowerCase());
},getEmptyElements: function(range) {
var applier = this;
return range.getNodes([1], function(el) {
return applier.appliesToElement(el) && !el.hasChildNodes();
});
},hasClass: function(node) {
return node.nodeType == 1 &&
(this.applyToAnyTagName || this.appliesToElement(node)) &&
hasClass(node, this.className);
},getSelfOrAncestorWithClass: function(node) {
while (node) {
if (this.hasClass(node)) {
return node;
}
node = node.parentNode;
}
return null;
},isModifiable: function(node) {
return !this.applyToEditableOnly || isEditable(node);
},
isIgnorableWhiteSpaceNode: function(node) {
return this.ignoreWhiteSpace && node && node.nodeType == 3 && isUnrenderedWhiteSpaceNode(node);
},
postApply: function(textNodes, range, positionsToPreserve, isUndo) {
var firstNode = textNodes[0], lastNode = textNodes[textNodes.length - 1];var merges = [], currentMerge;var rangeStartNode = firstNode, rangeEndNode = lastNode;
var rangeStartOffset = 0, rangeEndOffset = lastNode.length;var textNode, precedingTextNode;
forEach(textNodes, function(textNode) {
precedingTextNode = getPreviousMergeableTextNode(textNode, !isUndo);
if (precedingTextNode) {
if (!currentMerge) {
currentMerge = new Merge(precedingTextNode);
merges.push(currentMerge);
}
currentMerge.textNodes.push(textNode);
if (textNode === firstNode) {
rangeStartNode = currentMerge.textNodes[0];
rangeStartOffset = rangeStartNode.length;
}
if (textNode === lastNode) {
rangeEndNode = currentMerge.textNodes[0];
rangeEndOffset = currentMerge.getLength();
}
} else {
currentMerge = null;
}
});
var nextTextNode = getNextMergeableTextNode(lastNode, !isUndo);if (nextTextNode) {
if (!currentMerge) {
currentMerge = new Merge(lastNode);
merges.push(currentMerge);
}
currentMerge.textNodes.push(nextTextNode);
}
if (merges.length) {
for (i = 0, len = merges.length; i < len; ++i) {
merges[i].doMerge(positionsToPreserve);
}
range.setStartAndEnd(rangeStartNode, rangeStartOffset, rangeEndNode, rangeEndOffset);
}
},createContainer: function(parentNode) {
var doc = dom.getDocument(parentNode);
var namespace;
var el = createElementNSSupported && !dom.isHtmlNamespace(parentNode) && (namespace = parentNode.namespaceURI) ?
doc.createElementNS(parentNode.namespaceURI, this.elementTagName) :
doc.createElement(this.elementTagName);this.copyPropertiesToElement(this.elementProperties, el, false);
this.copyAttributesToElement(this.elementAttributes, el);
addClass(el, this.className);
if (this.onElementCreate) {
this.onElementCreate(el, this);
}
return el;
},elementHasProperties: function(el, props) {
var applier = this;
return each(props, function(p, propValue) {
if (p == "className") {
return hasAllClasses(el, propValue);
} else if (typeof propValue == "object") {
if (!applier.elementHasProperties(el[p], propValue)) {
return false;
}
} else if (el[p] !== propValue) {
return false;
}
});
},elementHasAttributes: function(el, attrs) {
return each(attrs, function(name, value) {
if (el.getAttribute(name) !== value) {
return false;
}
});
},applyToTextNode: function(textNode, positionsToPreserve) {if (canTextBeStyled(textNode)) {
var parent = textNode.parentNode;
if (parent.childNodes.length == 1 &&
this.useExistingElements &&
this.appliesToElement(parent) &&
this.elementHasProperties(parent, this.elementProperties) &&
this.elementHasAttributes(parent, this.elementAttributes)) {addClass(parent, this.className);
} else {
var textNodeParent = textNode.parentNode;
var el = this.createContainer(textNodeParent);
textNodeParent.insertBefore(el, textNode);
el.appendChild(textNode);
}
}},isRemovable: function(el) {
return el.tagName.toLowerCase() == this.elementTagName &&
getSortedClassName(el) == this.elementSortedClassName &&
this.elementHasProperties(el, this.elementProperties) &&
!elementHasNonClassAttributes(el, this.attrExceptions) &&
this.elementHasAttributes(el, this.elementAttributes) &&
this.isModifiable(el);
},isEmptyContainer: function(el) {
var childNodeCount = el.childNodes.length;
return el.nodeType == 1 &&
this.isRemovable(el) &&
(childNodeCount == 0 || (childNodeCount == 1 && this.isEmptyContainer(el.firstChild)));
},removeEmptyContainers: function(range) {
var applier = this;
var nodesToRemove = range.getNodes([1], function(el) {
return applier.isEmptyContainer(el);
});var rangesToPreserve = [range];
var positionsToPreserve = getRangeBoundaries(rangesToPreserve);forEach(nodesToRemove, function(node) {
removePreservingPositions(node, positionsToPreserve);
});
updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);
},undoToTextNode: function(textNode, range, ancestorWithClass, positionsToPreserve) {
if (!range.containsNode(ancestorWithClass)) {//var parent = ancestorWithClass.parentNode, index = dom.getNodeIndex(ancestorWithClass);
var ancestorRange = range.cloneRange();
ancestorRange.selectNode(ancestorWithClass);
if (ancestorRange.isPointInRange(range.endContainer, range.endOffset)) {
splitNodeAt(ancestorWithClass, range.endContainer, range.endOffset, positionsToPreserve);
range.setEndAfter(ancestorWithClass);
}
if (ancestorRange.isPointInRange(range.startContainer, range.startOffset)) {
ancestorWithClass = splitNodeAt(ancestorWithClass, range.startContainer, range.startOffset, positionsToPreserve);
}
}if (this.isRemovable(ancestorWithClass)) {
replaceWithOwnChildrenPreservingPositions(ancestorWithClass, positionsToPreserve);
} else {
removeClass(ancestorWithClass, this.className);
}
},splitAncestorWithClass: function(container, offset, positionsToPreserve) {
var ancestorWithClass = this.getSelfOrAncestorWithClass(container);
if (ancestorWithClass) {
splitNodeAt(ancestorWithClass, container, offset, positionsToPreserve);
}
},undoToAncestor: function(ancestorWithClass, positionsToPreserve) {
if (this.isRemovable(ancestorWithClass)) {
replaceWithOwnChildrenPreservingPositions(ancestorWithClass, positionsToPreserve);
} else {
removeClass(ancestorWithClass, this.className);
}
},applyToRange: function(range, rangesToPreserve) {
var applier = this;
rangesToPreserve = rangesToPreserve || [];
var positionsToPreserve = getRangeBoundaries(rangesToPreserve || []);range.splitBoundariesPreservingPositions(positionsToPreserve);
if (applier.removeEmptyElements) {
applier.removeEmptyContainers(range);
}var textNodes = getEffectiveTextNodes(range);if (textNodes.length) {
forEach(textNodes, function(textNode) {
if (!applier.isIgnorableWhiteSpaceNode(textNode) && !applier.getSelfOrAncestorWithClass(textNode) &&
applier.isModifiable(textNode)) {
applier.applyToTextNode(textNode, positionsToPreserve);
}
});
var lastTextNode = textNodes[textNodes.length - 1];
range.setStartAndEnd(textNodes[0], 0, lastTextNode, lastTextNode.length);
if (applier.normalize) {
applier.postApply(textNodes, range, positionsToPreserve, false);
}
updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);
}
var emptyElements = applier.getEmptyElements(range);forEach(emptyElements, function(el) {
addClass(el, applier.className);
});
},applyToRanges: function(ranges) {var i = ranges.length;
while (i--) {
this.applyToRange(ranges[i], ranges);
}
return ranges;
},applyToSelection: function(win) {
var sel = api.getSelection(win);
sel.setRanges( this.applyToRanges(sel.getAllRanges()) );
},undoToRange: function(range, rangesToPreserve) {
var applier = this;rangesToPreserve = rangesToPreserve || [];
var positionsToPreserve = getRangeBoundaries(rangesToPreserve);
range.splitBoundariesPreservingPositions(positionsToPreserve);
if (applier.removeEmptyElements) {
applier.removeEmptyContainers(range, positionsToPreserve);
}var textNodes = getEffectiveTextNodes(range);
var textNode, ancestorWithClass;
var lastTextNode = textNodes[textNodes.length - 1];if (textNodes.length) {
applier.splitAncestorWithClass(range.endContainer, range.endOffset, positionsToPreserve);
applier.splitAncestorWithClass(range.startContainer, range.startOffset, positionsToPreserve);
for (var i = 0, len = textNodes.length; i < len; ++i) {
textNode = textNodes[i];
ancestorWithClass = applier.getSelfOrAncestorWithClass(textNode);
if (ancestorWithClass && applier.isModifiable(textNode)) {
applier.undoToAncestor(ancestorWithClass, positionsToPreserve);
}
}range.setStartAndEnd(textNodes[0], 0, lastTextNode, lastTextNode.length);
if (applier.normalize) {
applier.postApply(textNodes, range, positionsToPreserve, true);
}
updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);
}
var emptyElements = applier.getEmptyElements(range);forEach(emptyElements, function(el) {
removeClass(el, applier.className);
});
},undoToRanges: function(ranges) {var i = ranges.length;while (i--) {
this.undoToRange(ranges[i], ranges);
}return ranges;
},undoToSelection: function(win) {
var sel = api.getSelection(win);
var ranges = api.getSelection(win).getAllRanges();
this.undoToRanges(ranges);
sel.setRanges(ranges);
},isAppliedToRange: function(range) {
if (range.collapsed || range.toString() == "") {
return !!this.getSelfOrAncestorWithClass(range.commonAncestorContainer);
} else {
var textNodes = range.getNodes( [3] );
if (textNodes.length)
for (var i = 0, textNode; textNode = textNodes[i++]; ) {
if (!this.isIgnorableWhiteSpaceNode(textNode) && rangeSelectsAnyText(range, textNode) &&
this.isModifiable(textNode) && !this.getSelfOrAncestorWithClass(textNode)) {
return false;
}
}
return true;
}
},isAppliedToRanges: function(ranges) {
var i = ranges.length;
if (i == 0) {
return false;
}
while (i--) {
if (!this.isAppliedToRange(ranges[i])) {
return false;
}
}
return true;
},isAppliedToSelection: function(win) {
var sel = api.getSelection(win);
return this.isAppliedToRanges(sel.getAllRanges());
},toggleRange: function(range) {
if (this.isAppliedToRange(range)) {
this.undoToRange(range);
} else {
this.applyToRange(range);
}
},toggleSelection: function(win) {
if (this.isAppliedToSelection(win)) {
this.undoToSelection(win);
} else {
this.applyToSelection(win);
}
},getElementsWithClassIntersectingRange: function(range) {
var elements = [];
var applier = this;
range.getNodes([3], function(textNode) {
var el = applier.getSelfOrAncestorWithClass(textNode);
if (el && !contains(elements, el)) {
elements.push(el);
}
});
return elements;
},detach: function() {}
};function createClassApplier(className, options, tagNames) {
return new ClassApplier(className, options, tagNames);
}ClassApplier.util = {
hasClass: hasClass,
addClass: addClass,
removeClass: removeClass,
getClass: getClass,
hasSameClasses: haveSameClasses,
hasAllClasses: hasAllClasses,
replaceWithOwnChildren: replaceWithOwnChildrenPreservingPositions,
elementsHaveSameNonClassAttributes: elementsHaveSameNonClassAttributes,
elementHasNonClassAttributes: elementHasNonClassAttributes,
splitNodeAt: splitNodeAt,
isEditableElement: isEditableElement,
isEditingHost: isEditingHost,
isEditable: isEditable
};api.CssClassApplier = api.ClassApplier = ClassApplier;
api.createClassApplier = createClassApplier;
util.createAliasForDeprecatedMethod(api, "createCssClassApplier", "createClassApplier", module);
});return rangy;
}, this);
(function() {// based on Backbone.js' inherits	
var ctor = function(){};
var inherits = function(parent, protoProps) {
var child;if (protoProps && protoProps.hasOwnProperty('constructor')) {
child = protoProps.constructor;
} else {
child = function(){ return parent.apply(this, arguments); };
}ctor.prototype = parent.prototype;
child.prototype = new ctor();if (protoProps) extend(child.prototype, protoProps);child.prototype.constructor = child;
child.__super__ = parent.prototype;
return child;
};function extend(target, ref) {
var name, value;
for ( name in ref ) {
value = ref[name];
if (value !== undefined) {
target[ name ] = value;
}
}
return target;
};var Undo = {
version: '0.1.15'
};Undo.Stack = function() {
this.commands = [];
this.stackPosition = -1;
this.savePosition = -1;
};extend(Undo.Stack.prototype, {
execute: function(command) {
this._clearRedo();
command.execute();
this.commands.push(command);
this.stackPosition++;
this.changed();
},
undo: function() {
this.commands[this.stackPosition].undo();
this.stackPosition--;
this.changed();
},
canUndo: function() {
return this.stackPosition >= 0;
},
redo: function() {
this.stackPosition++;
this.commands[this.stackPosition].redo();
this.changed();
},
canRedo: function() {
return this.stackPosition < this.commands.length - 1;
},
save: function() {
this.savePosition = this.stackPosition;
this.changed();
},
dirty: function() {
return this.stackPosition != this.savePosition;
},
_clearRedo: function() {
// TODO there's probably a more efficient way for this
this.commands = this.commands.slice(0, this.stackPosition + 1);
},
changed: function() {
// do nothing, override
}
});Undo.Command = function(name) {
this.name = name;
}

var up = new Error("override me!");extend(Undo.Command.prototype, {
execute: function() {
throw up;
},
undo: function() {
throw up;
},
redo: function() {
this.execute();
}
});Undo.Command.extend = function(protoProps) {
var child = inherits(this, protoProps);
child.extend = Undo.Command.extend;
return child;
};// AMD support
if (typeof define === "function" && define.amd) {
// Define as an anonymous module
define(Undo);
} else if(typeof module != "undefined" && module.exports){
module.exports = Undo 
}else {
this.Undo = Undo;
}
}).call(this);
!function(){if(self.Prism){var a={csharp:"C#",cpp:"C++"};Prism.hooks.add("before-highlight",function(e){var t=a[e.language]||e.language;e.element.setAttribute("data-language",t)})}}();;(function(e,h){var g=e.rangy||null,c=e.Undo||null,f=e.Key={backspace:8,tab:9,enter:13,shift:16,ctrl:17,alt:18,pause:19,capsLock:20,escape:27,pageUp:33,pageDown:34,end:35,home:36,leftArrow:37,upArrow:38,rightArrow:39,downArrow:40,insert:45,"delete":46,"0":48,"1":49,"2":50,"3":51,"4":52,"5":53,"6":54,"7":55,"8":56,"9":57,a:65,b:66,c:67,d:68,e:69,f:70,g:71,h:72,i:73,j:74,k:75,l:76,m:77,n:78,o:79,p:80,q:81,r:82,s:83,t:84,u:85,v:86,w:87,x:88,y:89,z:90,leftWindow:91,rightWindowKey:92,select:93,numpad0:96,numpad1:97,numpad2:98,numpad3:99,numpad4:100,numpad5:101,numpad6:102,numpad7:103,numpad8:104,numpad9:105,multiply:106,add:107,subtract:109,decimalPoint:110,divide:111,f1:112,f2:113,f3:114,f4:115,f5:116,f6:117,f7:118,f8:119,f9:120,f10:121,f11:122,f12:123,numLock:144,scrollLock:145,semiColon:186,equalSign:187,comma:188,dash:189,period:190,forwardSlash:191,graveAccent:192,openBracket:219,backSlash:220,closeBracket:221,singleQuote:222},b=(function(){var d=function(q){var v=this,r=a.deepExtend({},d.defaultSettings),n=this.settings=a.deepExtend(r,q),k=new d.Cache(),t=new d.Selection(),o=new d.Action(this),u=new d.Cursor(this),s=new d.Undoable(this),m,l,p;for(p in r){if(r.hasOwnProperty(p)){if(typeof r[p]!=="object"&&r.hasOwnProperty(p)&&n.element.getAttribute("data-medium-"+f)){l=n.element.getAttribute("data-medium-"+f);if(l.toLowerCase()==="false"||l.toLowerCase()==="true"){l=l.toLowerCase()==="true"}n[p]=l}}}if(n.modifiers){for(p in n.modifiers){if(n.modifiers.hasOwnProperty(p)){if(typeof(f[p])!=="undefined"){n.modifiers[f[p]]=n.modifiers[p]}}}}if(n.keyContext){for(p in n.keyContext){if(n.keyContext.hasOwnProperty(p)){if(typeof(f[p])!=="undefined"){n.keyContext[f[p]]=n.keyContext[p]}}}}m=n.element;m.contentEditable=true;m.className+=(" "+n.cssClasses.editor)+(" "+n.cssClasses.editor+"-"+n.mode);n.tags=(n.tags||{});if(n.tags.outerLevel){n.tags.outerLevel=n.tags.outerLevel.concat([n.tags.paragraph,n.tags.horizontalRule])}this.settings=n;this.element=m;m.medium=this;this.action=o;this.cache=k;this.cursor=u;this.utils=a;this.selection=t;v.clean();v.placeholders();o.preserveElementFocus();this.dirty=false;this.undoable=s;this.makeUndoable=s.makeUndoable;if(n.drag){v.drag=new d.Drag(v);v.drag.setup()}o.setup();k.initialized=true;this.makeUndoable(true)};d.prototype={placeholders:function(){if(!e.getComputedStyle){return}var u=this.settings,p=this.placeholder||(this.placeholder=h.createElement("div")),m=this.element,k=p.style,q=e.getComputedStyle(m,null),o=function(s){return q.getPropertyValue(s)},r=a.text(m),t=this.cursor,n=m.children.length,l=d.activeElement===m;m.placeholder=p;if(!l&&r.length<1&&n<2){if(m.placeHolderActive){return}if(!m.innerHTML.match("<"+u.tags.paragraph)){m.innerHTML=""}if(u.placeholder.length>0){if(!p.setup){p.setup=true;k.background=o("background");k.backgroundColor=o("background-color");k.fontSize=o("font-size");k.color=q.color;k.marginTop=o("margin-top");k.marginBottom=o("margin-bottom");k.marginLeft=o("margin-left");k.marginRight=o("margin-right");k.paddingTop=o("padding-top");k.paddingBottom=o("padding-bottom");k.paddingLeft=o("padding-left");k.paddingRight=o("padding-right");k.borderTopWidth=o("border-top-width");k.borderTopColor=o("border-top-color");k.borderTopStyle=o("border-top-style");k.borderBottomWidth=o("border-bottom-width");k.borderBottomColor=o("border-bottom-color");k.borderBottomStyle=o("border-bottom-style");k.borderLeftWidth=o("border-left-width");k.borderLeftColor=o("border-left-color");k.borderLeftStyle=o("border-left-style");k.borderRightWidth=o("border-right-width");k.borderRightColor=o("border-right-color");k.borderRightStyle=o("border-right-style");p.className=u.cssClasses.placeholder+" "+u.cssClasses.placeholder+"-"+u.mode;p.innerHTML="<div>"+u.placeholder+"</div>";m.parentNode.insertBefore(p,m)}m.className+=" "+u.cssClasses.clear;k.display="";k.minHeight=m.clientHeight+"px";k.minWidth=m.clientWidth+"px";if(u.mode!==d.inlineMode&&u.mode!==d.inlineRichMode){this.setupContents();if(n===0&&m.firstChild){t.set(this,0,m.firstChild)}}}m.placeHolderActive=true}else{if(m.placeHolderActive){m.placeHolderActive=false;k.display="none";m.className=a.trim(m.className.replace(u.cssClasses.clear,""));this.setupContents()}}},clean:function(k){var w=this.settings,n=w.cssClasses.placeholder,o=(w.attributes||{}).remove||[],x=w.tags||{},r=x.outerLevel||null,t=x.innerLevel||null,y={},v={},q=(x.paragraph||"").toUpperCase(),m=this.html,p,u,l;k=k||w.element;if(w.mode===d.inlineRichMode){r=w.tags.innerLevel}if(r!==null){for(l=0;l<r.length;l++){y[r[l].toUpperCase()]=true}}if(t!==null){for(l=0;l<t.length;l++){v[t[l].toUpperCase()]=true}}a.traverseAll(k,{element:function(E,z,C,A){var D=E.nodeName,s=true,B;for(l=0;l<o.length;l++){p=o[l];if(E.hasAttribute(p)){B=E.getAttribute(p);if(B!==n&&(!B.match("medium-")&&p==="class")){E.removeAttribute(p)}}}if(r===null&&t===null){return}if(C===1&&y[D]!==undefined){s=false}else{if(C>1&&v[D]!==undefined){s=false}}if(s){if(e.getComputedStyle(E,null).getPropertyValue("display")==="block"){if(q.length>0&&q!==D){a.changeTag(E,q)}if(C>1){while(A.childNodes.length>z){A.parentNode.insertBefore(A.lastChild,A.nextSibling)}}}else{switch(D){case"BR":if(E===E.parentNode.lastChild){if(E===E.parentNode.firstChild){break}u=h.createTextNode("");u.innerHTML="&nbsp";E.parentNode.insertBefore(u,E);break}default:while(E.firstChild!==null){E.parentNode.insertBefore(E.firstChild,E)}a.detachNode(E);break}}}}})},insertHtml:function(l,o,m){var k=(new d.Html(this,l)).insert(this.settings.beforeInsertHtml),n=k[k.length-1];if(m===true){a.triggerEvent(this.element,"change")}if(o){o.apply(k)}switch(n.nodeName){case"UL":case"OL":case"DL":if(n.lastChild!==null){this.cursor.moveCursorToEnd(n.lastChild);break}default:this.cursor.moveCursorToEnd(n)}return this},addTag:function(l,k,m,o){if(!this.settings.beforeAddTag(l,k,m,o)){var p=h.createElement(l),n;if(typeof m!=="undefined"&&m===false){p.contentEditable=false}if(p.innerHTML.length==0){p.innerHTML=" "}if(o&&o.nextSibling){o.parentNode.insertBefore(p,o.nextSibling);n=o.nextSibling}else{this.element.appendChild(p);n=this.lastChild()}if(k){this.cache.focusedElement=n;this.cursor.set(this,0,n)}return p}return null},invokeElement:function(m,l,o){var n=this.settings,k=l.remove||[];l=l||{};switch(n.mode){case d.inlineMode:case d.partialMode:return this;default:}if(k.length>0){if(!a.arrayContains(n,"class")){k.push("class")}}(new d.Element(this,m,l)).invoke(this.settings.beforeInvokeElement);if(o===true){a.triggerEvent(this.element,"change")}return this},value:function(k){if(typeof k!=="undefined"){this.element.innerHTML=k;this.clean();this.placeholders();this.makeUndoable()}else{return this.element.innerHTML}return this},focus:function(){var k=this.element;k.focus();return this},select:function(){a.selectNode(d.activeElement=this.element);return this},isActive:function(){return(d.activeElement===this.element)},setupContents:function(){var n=this.element,l=n.children,o=n.childNodes,k,m=this.settings;if(!m.tags.paragraph||l.length>0||m.mode===d.inlineMode||m.mode===d.inlineRichMode){return d.Utilities}if(o.length>0){k=h.createElement(m.tags.paragraph);if(n.innerHTML.match("^[&]nbsp[;]")){n.innerHTML=n.innerHTML.substring(6,n.innerHTML.length-1)}k.innerHTML=n.innerHTML;n.innerHTML="";n.appendChild(k)}else{k=h.createElement(m.tags.paragraph);k.innerHTML="&nbsp;";n.appendChild(k);this.cursor.set(this,0,n.firstChild)}return this},destroy:function(){var l=this.element,k=this.settings,m=this.placeholder||null;if(m!==null&&m.setup&&m.parentNode!==null){m.parentNode.removeChild(m);delete l.placeHolderActive}l.removeAttribute("contenteditable");l.className=a.trim(l.className.replace(k.cssClasses.editor,"").replace(k.cssClasses.clear,"").replace(k.cssClasses.editor+"-"+k.mode,""));this.action.destroy();if(this.settings.drag){this.drag.destroy()}},clear:function(){this.element.innerHTML="";this.placeholders()},splitAtCaret:function(){if(!this.isActive()){return null}var k=(e.getSelection||h.selection),q=k(),r=q.focusOffset,p=q.focusNode,m=this.element,l=h.createRange(),o=h.createRange(),n;l.setStart(p,r);o.selectNodeContents(m);l.setEnd(o.endContainer,o.endOffset);n=l.extractContents();return n},deleteSelection:function(){if(!this.isActive()){return}var l=g.getSelection(),k;if(l.rangeCount>0){k=l.getRangeAt(0);k.deleteContents()}},lastChild:function(){return this.element.lastChild},bold:function(){switch(this.settings.mode){case d.partialMode:case d.inlineMode:return this}(new d.Element(this,"bold")).setClean(false).invoke(this.settings.beforeInvokeElement);return this},underline:function(){switch(this.settings.mode){case d.partialMode:case d.inlineMode:return this}(new d.Element(this,"underline")).setClean(false).invoke(this.settings.beforeInvokeElement);return this},italicize:function(){switch(this.settings.mode){case d.partialMode:case d.inlineMode:return this}(new d.Element(this,"italic")).setClean(false).invoke(this.settings.beforeInvokeElement);return this},quote:function(){return this},paste:function(s){var p=this.value(),l=p.length,r,n=this.settings,q=this.selection,m=this.element,t=this,o=function(u){u=u||"";if(u.length>0){m.focus();d.activeElement=m;q.restoreSelection(k);u=a.encodeHtml(u);r=u.length+l;if(n.maxLength>0&&r>n.maxLength){u=u.substring(0,n.maxLength-l)}if(n.mode!==d.inlineMode){u=u.replace(/\n/g,"<br>")}(new d.Html(t,u)).setClean(false).insert(n.beforeInsertHtml,true);t.clean();t.placeholders()}};t.makeUndoable();if(s!==undefined){o(s)}else{if(n.pasteAsText){var k=q.saveSelection();a.pasteHook(this,o)}else{setTimeout(function(){t.clean();t.placeholders()},20)}}return true},undo:function(){var l=this.undoable,k=l.stack,m=k.canUndo();if(m){k.undo()}return this},
redo:function(){var l=this.undoable,k=l.stack,m=k.canRedo();if(m){k.redo()}return this}};d.inlineMode="inline";d.partialMode="partial";d.richMode="rich";d.inlineRichMode="inlineRich";d.Messages={pastHere:"Paste Here"};d.defaultSettings={element:null,modifier:"auto",placeholder:"",autofocus:false,autoHR:true,mode:d.richMode,maxLength:-1,modifiers:{b:"bold",i:"italicize",u:"underline"},tags:{"break":"br",horizontalRule:"hr",paragraph:"p",outerLevel:["pre","blockquote","figure"],innerLevel:["a","b","u","i","img","strong"]},cssClasses:{editor:"Medium",pasteHook:"Medium-paste-hook",placeholder:"Medium-placeholder",clear:"Medium-clear"},attributes:{remove:["style","class"]},pasteAsText:true,beforeInvokeElement:function(){},beforeInsertHtml:function(){},maxLengthReached:function(k){},beforeAddTag:function(l,k,m,n){},onBlur:function(){},onFocus:function(){},keyContext:null,drag:false};(function(l,k,n){function m(o){if(o.hasOwnProperty("target")&&o.target.getAttribute("contenteditable")==="false"){a.preventDefaultEvent(o);return false}return true}l.Action=function(o){this.medium=o;this.handledEvents={keydown:null,keyup:null,blur:null,focus:null,paste:null,click:null}};l.Action.prototype={setup:function(){this.handleFocus().handleBlur().handleKeyDown().handleKeyUp().handlePaste().handleClick()},destroy:function(){var o=this.medium.element;a.removeEvent(o,"focus",this.handledEvents.focus).removeEvent(o,"blur",this.handledEvents.blur).removeEvent(o,"keydown",this.handledEvents.keydown).removeEvent(o,"keyup",this.handledEvents.keyup).removeEvent(o,"paste",this.handledEvents.paste).removeEvent(o,"click",this.handledEvents.click)},handleFocus:function(){var o=this.medium,p=o.element;a.addEvent(p,"focus",this.handledEvents.focus=function(q){q=q||k.event;if(!m(q)){return false}l.activeElement=p;o.cache.originalVal=q.target.textContent;o.settings.onFocus(q);o.placeholders()});return this},handleBlur:function(){var o=this.medium,p=o.element;a.addEvent(p,"blur",this.handledEvents.blur=function(q){q=q||k.event;if(l.activeElement===p){l.activeElement=null}o.settings.onBlur(q);o.placeholders()});return this},handleKeyDown:function(){var s=this,p=this.medium,r=p.settings,o=p.cache,q=p.element;a.addEvent(q,"keydown",this.handledEvents.keydown=function(z){z=z||k.event;if(!m(z)){return false}var u=true;if(z.keyCode===229){return}a.isCommand(r,z,function(){o.cmd=true},function(){o.cmd=false});a.isShift(z,function(){o.shift=true},function(){o.shift=false});a.isModifier(r,z,function(C){if(o.cmd){if((r.mode===l.inlineMode)||(r.mode===l.partialMode)){a.preventDefaultEvent(z);return false}var B=typeof C;var A=null;if(B==="function"){A=C}else{A=p[C]}u=A.call(p,z);if(u===false||u===p){a.preventDefaultEvent(z);a.stopPropagation(z)}return true}return false});if(r.maxLength!==-1){var t=a.text(q).length,v=false,y=k.getSelection(),x=a.isSpecial(z),w=a.isNavigational(z);if(y){v=!y.isCollapsed}if(x||w){return true}if(t>=r.maxLength&&!v){r.maxLengthReached(q);a.preventDefaultEvent(z);return false}}switch(z.keyCode){case f.enter:if(s.enterKey(z)===false){a.preventDefaultEvent(z)}break;case f.escape:if(s.escKey(z)===false){a.preventDefaultEvent(z)}break;case f.backspace:case f["delete"]:s.backspaceOrDeleteKey(z);break}return u});return this},handleKeyUp:function(){var s=this,p=this.medium,r=p.settings,o=p.cache,t=p.cursor,q=p.element;a.addEvent(q,"keyup",this.handledEvents.keyup=function(w){w=w||k.event;if(!m(w)){return false}a.isCommand(r,w,function(){o.cmd=false},function(){o.cmd=true});p.clean();p.placeholders();var v;if(r.keyContext!==null&&(v=r.keyContext[w.keyCode])){var u=t.parent();if(u){v.call(p,w,u)}}s.preserveElementFocus()});return this},handlePaste:function(){var w=this.medium,o=w.element,v,q,u,p,s,t,r;a.addEvent(o,"paste",this.handledEvents.paste=function(x){x=x||k.event;if(!m(x)){return false}q=0;a.preventDefaultEvent(x);v="";s=x.clipboardData;if(s&&(p=s.getData)){r=s.types;u=r.length;for(q=0;q<u;q++){t=r[q];switch(t){case"text/plain":return w.paste(s.getData("text/plain"))}}}w.paste()});return this},handleClick:function(){var o=this.medium,p=o.element,q=o.cursor;a.addEvent(p,"click",this.handledEvents.click=function(r){if(!m(r)){q.caretToAfter(r.target)}});return this},escKey:function(s){var p=this.medium,r=p.element,q=p.settings,o=p.cache;if(q.mode===l.inlineMode||q.mode===l.inlineRichMode){s.target.textContent=o.originalVal;if(q.element.blur){q.element.blur()}else{if(q.element.onblur){q.element.onblur()}}return false}},enterKey:function(v){var z=this.medium,q=z.element,s=z.settings,o=z.cache,y=z.cursor;if(s.mode===l.inlineMode||s.mode===l.inlineRichMode){if(s.element.blur){s.element.blur()}else{if(s.element.onblur){s.element.onblur()}}return false}if(o.shift){if(s.tags["break"]){z.addTag(s.tags["break"],true);return false}}else{var w=a.atCaret(z)||{},r=q.children,p=w===q.lastChild?q.lastChild:null,u,x,t;if(p&&p!==q.firstChild&&s.autoHR&&s.mode!==l.partialMode&&s.tags.horizontalRule){a.preventDefaultEvent(v);u=a.text(p)===""&&p.nodeName.toLowerCase()===s.tags.paragraph;if(u&&r.length>=2){x=r[r.length-2];if(x.nodeName.toLowerCase()===s.tags.horizontalRule){u=false}}if(u){z.addTag(s.tags.horizontalRule,false,true,w);w=w.nextSibling}if((t=z.addTag(s.tags.paragraph,true,null,w))!==null){t.innerHTML="";y.set(z,0,t)}}}return true},backspaceOrDeleteKey:function(s){var v=this.medium,u=v.cursor,r=v.settings,p=v.element;if(r.onBackspaceOrDelete!==undefined){var w=r.onBackspaceOrDelete.call(v,s,p);if(w){return}}if(p.lastChild===null){return}var o=p.lastChild,q=o.previousSibling,t=g.getSelection().anchorNode;if(o&&r.tags.horizontalRule&&o.nodeName.toLocaleLowerCase()===r.tags.horizontalRule){p.removeChild(o)}else{if(o&&q&&a.text(o).length<1&&q.nodeName.toLowerCase()===r.tags.horizontalRule&&o.nodeName.toLowerCase()===r.tags.paragraph){p.removeChild(o);p.removeChild(q)}else{if(p.childNodes.length===1&&o&&!a.text(o).length){a.preventDefaultEvent(s);v.setupContents()}else{if(t&&t===p){v.deleteSelection();v.setupContents();u.set(v,0,p.firstChild)}}}}},preserveElementFocus:function(){var w=k.getSelection?k.getSelection().anchorNode:document.activeElement;if(w){var x=this.medium,o=x.cache,p=x.element,y=x.settings,v=w.parentNode,q=p.children,u=v!==o.focusedElement,r=0,t;if(v===y.element){v=w}for(t=0;t<q.length;t++){if(v===q[t]){r=t;break}}if(u){o.focusedElement=v;o.focusedElementIndex=r}}}}})(d,e,h);(function(k){k.Cache=function(){this.initialized=false;this.cmd=false;this.focusedElement=null;this.originalVal=null}})(d);(function(k){k.Cursor=function(l){this.medium=l};k.Cursor.prototype={set:function(s,o){var l;if(h.createRange){var n=e.getSelection(),r=this.medium.lastChild(),q=a.text(r).length-1,m=o?o:r,p=((typeof s!=="undefined")&&(s!==null)?s:q);l=h.createRange();l.setStart(m,p);l.collapse(true);n.removeAllRanges();n.addRange(l)}else{l=h.body.createTextRange();l.moveToElementText(o);l.collapse(false);l.select()}},moveCursorToEnd:function(n){var m=g.getSelection(),l=g.createRange();l.setStartAfter(n);l.setEnd(n,n.length||n.childNodes.length);m.removeAllRanges();m.addRange(l)},moveCursorToAfter:function(m){var n=g.getSelection();if(n.rangeCount){var l=n.getRangeAt(0);l.collapse(false);l.collapseAfter(m);n.setSingleRange(l)}},parent:function(){var m=null,l;if(e.getSelection){l=e.getSelection().getRangeAt(0);m=l.commonAncestorContainer;m=(m.nodeType===1?m:m.parentNode)}else{if(h.selection){m=h.selection.createRange().parentElement()}}if(m.tagName=="SPAN"){m=m.parentNode}return m},caretToBeginning:function(l){this.set(0,l)},caretToEnd:function(l){this.moveCursorToEnd(l)},caretToAfter:function(l){this.moveCursorToAfter(l)}}})(d);(function(k){k.Drag=function(m){this.medium=m;var o=this,l=this.iconSrc.replace(/[{][{]([a-zA-Z]+)[}][}]/g,function(q,p){if(o.hasOwnProperty(p)){return o[p]}return q}),n=this.icon=h.createElement("img");n.className=this.buttonClass;n.setAttribute("contenteditable","false");n.setAttribute("src",l);this.hide();this.element=null;this.protectedElement=null;this.handledEvents={dragstart:null,dragend:null,mouseover:null,mouseout:null,mousemove:null}};k.Drag.prototype={elementClass:"Medium-focused",buttonClass:"Medium-drag",iconSrc:'data:image/svg+xml;utf8,<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="21.424px" height="21.424px" viewBox="0 0 21.424 21.424" style="enable-background:new 0 0 21.424 21.424;" xml:space="preserve">	<g>		<g>			<path style="fill:{{iconColor}};" d="M13.616,17.709L13.616,17.709h0.781l-3.686,3.715l-3.685-3.715h0.781l0,0H13.616z M13.616,17.709 M14.007,17.709 M12.555,19.566 M8.87,19.566 M7.418,17.709 M7.809,17.709 M10.712,17.709"/>			<path style="fill:{{iconColor}};" d="M13.616,3.715L13.616,3.715h0.781L10.712,0L7.027,3.715h0.781l0,0H13.616z M13.616,3.715 M14.007,3.715 M12.555,1.858 M8.87,1.858 M7.418,3.715 M7.809,3.715 M10.712,3.715"/>			<path style="fill:{{iconColor}};" d="M3.716,13.616L3.716,13.616v0.781L0,10.712l3.716-3.685v0.781l0,0V13.616z M3.716,13.616 M3.716,14.007 M1.858,12.555 M1.858,8.87 M3.716,7.417 M3.716,7.808 M3.716,10.712"/>			<path style="fill:{{iconColor}};" d="M17.709,13.616L17.709,13.616v0.781l3.715-3.685l-3.715-3.685v0.781l0,0V13.616z M17.709,13.616 M17.709,14.007 M19.566,12.555 M19.566,8.87 M17.709,7.417 M17.709,7.808 M17.709,10.712"/>		</g>		<path style="fill-rule:evenodd;clip-rule:evenodd;fill:{{iconColor}};" d="M10.712,6.608c2.267,0,4.104,1.838,4.104,4.104 c0,2.266-1.837,4.104-4.104,4.104c-2.266,0-4.104-1.837-4.104-4.104C6.608,8.446,8.446,6.608,10.712,6.608L10.712,6.608z M10.712,7.515c-1.765,0-3.196,1.432-3.196,3.197s1.432,3.197,3.196,3.197c1.766,0,3.197-1.432,3.197-3.197 S12.478,7.515,10.712,7.515z"/>	</g></svg>',iconColor:"#231F20",setup:function(){this.handleDragstart().handleDragend().handleMouseover().handleMouseout().handleMousemove();return this},
destroy:function(){a.removeEvent(this.icon,"dragstart",this.handledEvents.dragstart).removeEvent(this.icon,"dragend",this.handledEvents.dragend).removeEvent(this.icon,"mouseover",this.handledEvents.mouseover).removeEvent(this.icon,"mouseout",this.handledEvents.mouseout).removeEvent(this.medium.element,"mousemove",this.handledEvents.mousemove);return this},hide:function(){a.hide(this.icon);return this},handleDragstart:function(){var l=this;a.addEvent(this.icon,"dragstart",this.handledEvents.dragstart=function(m){if(l.protectedElement!==null){return}m=m||e.event;l.protectedElement=a.detachNode(l.element);l.icon.style.opacity=0});return this},handleDragend:function(){var l=this;a.addEvent(this.icon,"dragend",this.handledEvents.dragend=h.body.ondragend=function(m){if(l.protectedElement===null){return}setTimeout(function(){l.cleanCanvas();l.protectedElement=null},1)});return this},handleMouseover:function(){var l=this;a.addEvent(this.icon,"mouseover",this.handledEvents.mouseover=function(m){if(l.protectedElement!==null){return}a.stopPropagation(m).addClass(l.element,l.elementClass)});return this},handleMouseout:function(){var l=this;a.addEvent(this.icon,"mouseout",this.handledEvents.mouseout=function(m){if(l.protectedElement!==null){return}a.stopPropagation(m).removeClass(l.element,l.elementClass)});return this},handleMousemove:function(){var l=this;a.addEvent(this.medium.element,"mousemove",this.handledEvents.mousemove=function(n){n=n||e.event;var m=n.target||{};if(m.getAttribute("contenteditable")==="false"){l.show(m)}});return this},show:function(m){if(m===this.icon&&this.protectedElement===null){return}this.element=m;var l=this.icon.style,o=m.offsetLeft,n=m.offsetTop;m.dragIcon=this.icon;m.parentNode.appendChild(this.icon);l.opacity=1;l.left=o+"px";l.top=n+"px";a.show(this.icon);return this},cleanCanvas:function(){var n,l=false,m=h.getElementsByClassName(this.buttonClass);this.icon.style.opacity=1;while(m.length>0){if(a.isVisible(n=m[0])){if(!l){n.parentNode.insertBefore(this.element,n);l=true}a.detachNode(n)}}a.detachNode(this.icon);return this}}})(d);(function(k){k.Element=function(m,n,l){this.medium=m;this.element=m.element;switch(n.toLowerCase()){case"bold":this.tagName="b";break;case"italic":this.tagName="i";break;case"underline":this.tagName="u";break;default:this.tagName=n}this.attributes=l||{};this.clean=true};k.Element.prototype={invoke:function(p){if(k.activeElement===this.element){if(p){p.apply(this)}var l=this.attributes,o=this.tagName.toLowerCase(),n,m;if(l.className!==undefined){m=(l.className.split[" "]||[l.className]).shift();delete l.className}else{m="medium-"+o}n=g.createClassApplier(m,{elementTagName:o,elementAttributes:this.attributes});this.medium.makeUndoable();n.toggleSelection(e);if(this.clean){this.medium.clean();this.medium.placeholders()}}},setClean:function(l){this.clean=l;return this}}})(d);(function(k){k.Html=function(l,m){this.html=m;this.medium=l;this.clean=true;this.injector=new k.Injector()};k.Html.prototype={insert:function(n,m){if(k.activeElement===this.medium.element){if(n){n.apply(this)}var l=this.injector.inject(this.html,m);if(this.clean){this.medium.clean();this.medium.placeholders()}this.medium.makeUndoable();return l}else{return null}},setClean:function(l){this.clean=l;return this}}})(d);(function(k){k.Injector=function(){};k.Injector.prototype={inject:function(n){var m=[],p,l=false;if(typeof n==="string"){var s=h.createElement("div");s.innerHTML=n;p=s.childNodes;l=true}else{p=n}this.insertHTML('<span id="Medium-wedge"></span>');var r=h.getElementById("Medium-wedge"),q=r.parentNode,o=0;r.removeAttribute("id");if(l){while(o<p.length){m.push(p[o]);o++}while(p.length>0){q.insertBefore(p[0],r)}}else{m.push(p);q.insertBefore(p,r)}q.removeChild(r);r=null;return m},insertHTML:function(r,t){var n,s;if(e.getSelection){n=e.getSelection();if(n.getRangeAt&&n.rangeCount){s=n.getRangeAt(0);s.deleteContents();var o=h.createElement("div");o.innerHTML=r;var u=h.createDocumentFragment(),p,m;while((p=o.firstChild)){m=u.appendChild(p)}var l=u.firstChild;s.insertNode(u);if(m){s=s.cloneRange();s.setStartAfter(m);if(t){s.setStartBefore(l)}else{s.collapse(true)}n.removeAllRanges();n.addRange(s)}}}else{if((n=h.selection)&&n.type!="Control"){var q=n.createRange();q.collapse(true);n.createRange().pasteHTML(r);if(t){s=n.createRange();s.setEndPoint("StartToStart",q);s.select()}}}}}})(d);(function(k){k.Selection=function(){};k.Selection.prototype={saveSelection:function(){if(e.getSelection){var l=e.getSelection();if(l.rangeCount>0){return l.getRangeAt(0)}}else{if(h.selection&&h.selection.createRange){return h.selection.createRange()}}return null},restoreSelection:function(l){if(l){if(e.getSelection){var m=e.getSelection();m.removeAllRanges();m.addRange(l)}else{if(h.selection&&l.select){l.select()}}}}}})(d);(function(k){k.Toolbar=function(l,n){this.medium=l;var m=h.createElement("div");m.innerHTML=this.html;this.buttons=n;this.element=m.children[0];h.body.appendChild(this.element);this.active=false;this.busy=true;this.handledEvents={scroll:null,mouseup:null,keyup:null}};k.Toolbar.prototype={fixedClass:"Medium-toolbar-fixed",showClass:"Medium-toolbar-show",hideClass:"Medium-toolbar-hide",html:'<div class="Medium-toolbar">				<div class="Medium-tail-outer">					<div class="Medium-tail-inner"></div>				</div>				<div id="Medium-buttons"></div>				<table id="Medium-options">					<tbody>						<tr>						</tr>					</tbody>				</table>			</div>',setup:function(){this.handleScroll().handleMouseup().handleKeyup()},destroy:function(){a.removeEvent(e,"scroll",this.handledEvents.scroll).removeEvent(h,"mouseup",this.handledEvents.mouseup).removeEvent(h,"keyup",this.handledEvents.keyup)},handleScroll:function(){var l=this;a.addEvent(e,"scroll",this.handledEvents.scroll=function(){if(l.active){l.goToSelection()}});return this},handleMouseup:function(){var l=this;a.addEvent(h,"mouseup",this.handledEvents.mouseup=function(){if(k.activeElement===l.medium.element&&!l.busy){l.goToSelection()}});return this},handleKeyup:function(){var l=this;a.addEvent(h,"keyup",this.handledEvents.keyup=function(){if(k.activeElement===l.medium.element&&!l.busy){l.goToSelection()}});return this},goToSelection:function(){var n=this.getHighlighted(),o=n.boundary.top-5,m=this.element,l=m.style;if(e.scrollTop>0){a.addClass(m,this.fixedClass)}else{a.removeClass(m,this.fixedClass)}if(n!==null){if(n.range.startOffset===n.range.endOffset&&!n.text){a.removeClass(m,this.showClass).addClass(m,this.hideClass);this.active=false}else{a.removeClass(m,this.hideClass).removeClass(m,this.showClass);l.opacity=0.01;a.addClass(m,this.showClass);l.opacity=1;l.top=(o-65)+"px";l.left=((n.boundary.left+(n.boundary.width/2))-(m.clientWidth/2))+"px";this.active=true}}},getHighlighted:function(){var m=e.getSelection(),l=(m.anchorNode?m.getRangeAt(0):false);if(!l){return null}return{selection:m,range:l,text:a.trim(l.toString()),boundary:l.getBoundingClientRect()}}}})(d);(function(k){k.Undoable=function(o){var r=this,p=o.settings.element,s,n,l=new Undo.Stack(),q=Undo.Command.extend({constructor:function(t,u){this.oldValue=t;this.newValue=u},execute:function(){},undo:function(){p.innerHTML=this.oldValue;o.canUndo=l.canUndo();o.canRedo=l.canRedo();o.dirty=l.dirty()},redo:function(){p.innerHTML=this.newValue;o.canUndo=l.canUndo();o.canRedo=l.canRedo();o.dirty=l.dirty()}}),m=function(u){var t=p.innerHTML;if(u){n=p.innerHTML;l.execute(new q(n,n))}else{if(t!=n){if(!r.movingThroughStack){l.execute(new q(n,t));n=t;o.dirty=l.dirty()}a.triggerEvent(o.settings.element,"change")}}};this.medium=o;this.timer=s;this.stack=l;this.makeUndoable=m;this.EditCommand=q;this.movingThroughStack=false;a.addEvent(p,"keyup",function(t){if(t.ctrlKey||t.keyCode===f.z){a.preventDefaultEvent(t);return}clearTimeout(s);s=setTimeout(function(){m()},250)}).addEvent(p,"keydown",function(t){if(!t.ctrlKey||t.keyCode!==f.z){r.movingThroughStack=false;return}a.preventDefaultEvent(t);r.movingThroughStack=true;if(t.shiftKey){l.canRedo()&&l.redo()}else{l.canUndo()&&l.undo()}})}})(d);d.Utilities={isCommand:function(l,n,m,k){if((l.modifier==="ctrl"&&n.ctrlKey)||(l.modifier==="cmd"&&n.metaKey)||(l.modifier==="auto"&&(n.ctrlKey||n.metaKey))){return m.call()}else{return k.call()}},isShift:function(m,l,k){if(m.shiftKey){return l.call()}else{return k.call()}},isModifier:function(l,n,k){var m=l.modifiers[n.keyCode];if(m){return k.call(null,m)}return false},special:(function(){var k={};k[f.backspace]=true;k[f.shift]=true;k[f.ctrl]=true;k[f.alt]=true;k[f["delete"]]=true;k[f.cmd]=true;return k})(),isSpecial:function(k){return typeof d.Utilities.special[k.keyCode]!=="undefined"},navigational:(function(){var k={};k[f.upArrow]=true;k[f.downArrow]=true;k[f.leftArrow]=true;k[f.rightArrow]=true;return k})(),isNavigational:function(k){return typeof d.Utilities.navigational[k.keyCode]!=="undefined"},addEvents:function(o,p,q){var n=0,m,r=p.split(" "),k=r.length,l=d.Utilities;for(;n<k;n++){m=r[n];if(m.length>0){l.addEvent(o,m,q)}}return d.Utilities},addEvent:function i(l,k,m){if(l.addEventListener){l.addEventListener(k,m,false)}else{if(l.attachEvent){l.attachEvent("on"+k,m)}else{l["on"+k]=m}}return d.Utilities},removeEvent:function j(l,k,m){if(l.removeEventListener){l.removeEventListener(k,m,false)}else{if(l.detachEvent){l.detachEvent("on"+k,m)}else{l["on"+k]=null}}return d.Utilities},preventDefaultEvent:function(k){if(k.preventDefault){k.preventDefault()}else{k.returnValue=false}return d.Utilities},stopPropagation:function(k){k=k||e.event;k.cancelBubble=true;if(k.stopPropagation!==undefined){k.stopPropagation()}return d.Utilities},isEventSupported:function(m,k){k="on"+k;var n=h.createElement(m.tagName),l=(k in n);if(!l){n.setAttribute(k,"return;");l=typeof n[k]=="function"}n=null;return l},triggerEvent:function(l,k){var m;if(h.createEvent){m=h.createEvent("HTMLEvents");m.initEvent(k,true,true);m.eventName=k;l.dispatchEvent(m)}else{m=h.createEventObject();l.fireEvent("on"+k,m)}return d.Utilities},deepExtend:function(k,n){var m,l;for(m in n){if(n.hasOwnProperty(m)){l=n[m];if(l!==undefined&&l!==null&&l.constructor!==undefined&&l.constructor===Object){k[m]=k[m]||{};d.Utilities.deepExtend(k[m],l)}else{k[m]=l}}}return k},pasteHook:function(w,r){w.makeUndoable();var o=h.createElement("div"),l=w.element,v,m,p,x=w.settings,t,q=h.body,u=q.parentNode,k=u.scrollTop,n=u.scrollLeft;o.className=x.cssClasses.pasteHook;o.setAttribute("contenteditable",true);q.appendChild(o);a.selectNode(o);u.scrollTop=k;u.scrollLeft=n;setTimeout(function(){t=a.text(o);l.focus();if(x.maxLength>0){v=a.text(l);m=v.length;p=m+t.length;if(p>m){t=t.substring(0,x.maxLength-m)}}a.detachNode(o);u.scrollTop=k;u.scrollLeft=n;r(t)},0);return d.Utilities},traverseAll:function(n,k,q){var m=n.childNodes,p=m.length,l=0,o;q=q||1;k=k||{};if(p>0){for(;l<p;l++){o=m[l];switch(o.nodeType){case 1:d.Utilities.traverseAll(o,k,q+1);if(k.element!==undefined){k.element(o,l,q,n)}break;case 3:if(k.fragment!==undefined){k.fragment(o,l,q,n)}}p=m.length;if(o===n.lastChild){l=p}}}return d.Utilities},trim:function(k){return k.replace(/^[\s]+|\s+$/g,"")},arrayContains:function(m,k){var l=m.length;while(l--){if(m[l]===k){return true}}return false},addClass:function(l,k){if(l.classList){l.classList.add(k)}else{l.className+=" "+k}return d.Utilities},removeClass:function(l,k){if(l.classList){l.classList.remove(k)}else{l.className=l.className.replace(new RegExp("(^|\b)"+k.split(" ").join("|")+"(\b|$)","gi")," ")}return d.Utilities},hasClass:function(l,k){if(l.classList){return l.classList.contains(k)}else{return new RegExp("(^| )"+k+"( |$)","gi").test(l.className)}},isHidden:function(k){return k.offsetWidth===0||k.offsetHeight===0},isVisible:function(k){return k.offsetWidth!==0||k.offsetHeight!==0},encodeHtml:function(k){return h.createElement("a").appendChild(h.createTextNode(k)).parentNode.innerHTML},text:function(k,l){if(l!==undefined){if(k===null){return this}if(k.textContent!==undefined){k.textContent=l}else{k.innerText=l}return this}else{if(k===null){return this}else{if(k.innerText!==undefined){return a.trim(k.innerText)}else{if(k.textContent!==undefined){return a.trim(k.textContent)}else{if(k.data!==undefined){return a.trim(k.data)}}}}}return""},changeTag:function(o,m){var l=h.createElement(m),n,k;n=o.firstChild;while(n){k=n.nextSibling;l.appendChild(n);n=k}o.parentNode.insertBefore(l,o);o.parentNode.removeChild(o);return l},detachNode:function(k){if(k.parentNode!==null){k.parentNode.removeChild(k)}return this},selectNode:function(m){var k,l;m.focus();if(h.body.createTextRange){k=h.body.createTextRange();k.moveToElementText(m);k.select()}else{if(e.getSelection){l=e.getSelection();k=h.createRange();k.selectNodeContents(m);l.removeAllRanges();l.addRange(k)}}return this},baseAtCaret:function(m){if(!m.isActive()){return null}var n=e.getSelection?e.getSelection():document.selection;if(n.rangeCount){var l=n.getRangeAt(0),k=l.endContainer;switch(k.nodeType){case 3:if(k.data&&k.data.length!=l.endOffset){return false}break}return k}return null},atCaret:function(l){var k=this.baseAtCaret(l)||{},m=l.element;if(k===false){return null}while(k&&k.parentNode!==m){k=k.parentNode}if(k&&k.nodeType==1){return k}return null},hide:function(k){k.style.display="none";return d.Utilities},show:function(k){k.style.display="";return d.Utilities},hideAnim:function(k){k.style.opacity=1;return d.Utilities},showAnim:function(k){k.style.opacity=0.01;k.style.display="";return d.Utilities},setWindow:function(k){e=k;return d.Utilities},setDocument:function(k){h=k;return d.Utilities}};g.rangePrototype.insertNodeAtEnd=function(l){var k=this.cloneRange();k.collapse(false);k.insertNode(l);k.detach();this.setEndAfter(l)};return d}()),a=b.Utilities;if(typeof define==="function"&&define.amd){define(function(){return b})}else{if(typeof module!=="undefined"&&module.exports){module.exports=b}else{if(typeof this!=="undefined"){this.Medium=b}}}}).call(this,window,document);